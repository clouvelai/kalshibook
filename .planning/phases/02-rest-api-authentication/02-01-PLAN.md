---
phase: 02-rest-api-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/api/__init__.py
  - src/api/main.py
  - src/api/deps.py
  - src/api/models.py
  - src/api/errors.py
  - src/api/services/__init__.py
  - src/api/services/auth.py
  - src/api/routes/__init__.py
  - src/shared/config.py
  - src/shared/db.py
  - supabase/migrations/20260214000001_create_api_keys.sql
  - .env.example
autonomous: true

must_haves:
  truths:
    - "FastAPI app starts and responds to health check at GET /health"
    - "api_keys table exists in database with correct schema"
    - "API key can be generated with kb- prefix and stored as SHA-256 hash"
    - "API key validation dependency rejects invalid/missing keys with structured error"
    - "Error responses follow Tavily-style envelope with code, message, status, request_id"
  artifacts:
    - path: "src/api/main.py"
      provides: "FastAPI application with lifespan, middleware, all router includes"
      contains: "FastAPI"
    - path: "src/api/deps.py"
      provides: "API key auth dependency, DB pool dependency"
      contains: "Depends"
    - path: "src/api/models.py"
      provides: "Pydantic request/response models for all endpoints"
      contains: "BaseModel"
    - path: "src/api/errors.py"
      provides: "Error envelope, exception handlers, KalshiBookError"
      contains: "ErrorResponse"
    - path: "src/api/services/auth.py"
      provides: "API key generation, hashing, database operations"
      contains: "generate_api_key"
    - path: "supabase/migrations/20260214000001_create_api_keys.sql"
      provides: "api_keys table with key_hash, key_prefix, user_id, rate_limit"
      contains: "CREATE TABLE"
  key_links:
    - from: "src/api/deps.py"
      to: "src/api/services/auth.py"
      via: "get_api_key calls validate_api_key"
      pattern: "validate_api_key"
    - from: "src/api/main.py"
      to: "src/shared/db.py"
      via: "lifespan creates/closes asyncpg pool"
      pattern: "create_pool"
    - from: "src/api/errors.py"
      to: "src/api/models.py"
      via: "exception handlers return ErrorResponse"
      pattern: "ErrorResponse"
---

<objective>
Set up the FastAPI application foundation: app skeleton with lifespan, dependency injection, error handling, Pydantic models, API key infrastructure (migration + service), and all router registrations. This plan creates every file that Plans 02 and 03 depend on.

Purpose: Establish the shared foundation (app, auth, errors, models) so data endpoints and auth endpoints can be built independently in parallel.
Output: Running FastAPI app with health endpoint, structured errors, API key infrastructure, and pre-registered routers for all endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rest-api-authentication/02-RESEARCH.md
@.planning/phases/02-rest-api-authentication/02-CONTEXT.md
@src/shared/config.py
@src/shared/db.py
@src/collector/models.py
@supabase/migrations/20260213000001_create_markets.sql
@supabase/migrations/20260213000002_create_snapshots.sql
@supabase/migrations/20260213000003_create_deltas.sql
@pyproject.toml
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create API key migration</name>
  <files>
    pyproject.toml
    supabase/migrations/20260214000001_create_api_keys.sql
    .env.example
  </files>
  <action>
    1. Add FastAPI dependencies to pyproject.toml:
       ```
       uv add fastapi uvicorn slowapi supabase python-multipart
       ```

    2. Create the api_keys table migration at `supabase/migrations/20260214000001_create_api_keys.sql`:
       ```sql
       CREATE TABLE IF NOT EXISTS api_keys (
           id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
           user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
           key_hash TEXT NOT NULL UNIQUE,
           key_prefix TEXT NOT NULL,  -- first 7 chars for display: "kb-abc..."
           name TEXT NOT NULL DEFAULT 'Default',
           rate_limit INT NOT NULL DEFAULT 100,  -- requests per minute
           created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
           last_used_at TIMESTAMPTZ,
           revoked_at TIMESTAMPTZ
       );
       CREATE INDEX idx_api_keys_hash ON api_keys (key_hash) WHERE revoked_at IS NULL;
       CREATE INDEX idx_api_keys_user ON api_keys (user_id);
       ```

    3. Update `.env.example` to add API-related env vars (add section after existing Supabase vars):
       ```
       # API Server
       API_HOST=0.0.0.0
       API_PORT=8000
       API_RATE_LIMIT_DEFAULT=100
       ```

    Apply the migration locally:
    ```bash
    supabase db reset
    ```
    Or if Supabase is already running:
    ```bash
    supabase migration up
    ```
  </action>
  <verify>
    - `uv run python -c "import fastapi; import uvicorn; import slowapi; print('OK')"` succeeds
    - Migration file exists and has correct SQL syntax
    - Run `supabase db reset` or verify migration applies cleanly
  </verify>
  <done>
    FastAPI, uvicorn, slowapi, supabase, python-multipart in pyproject.toml dependencies. api_keys migration ready. .env.example updated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI app, error handling, and Pydantic models</name>
  <files>
    src/api/__init__.py
    src/api/main.py
    src/api/errors.py
    src/api/models.py
    src/api/routes/__init__.py
    src/shared/config.py
    src/shared/db.py
  </files>
  <action>
    1. Create `src/api/__init__.py` (empty).

    2. Create `src/api/routes/__init__.py` (empty).

    3. Update `src/shared/config.py` — add API settings to the Settings class:
       - `api_host: str = "0.0.0.0"`
       - `api_port: int = 8000`
       - `api_rate_limit_default: int = 100`  (requests per minute)

    4. Update `src/shared/db.py` — the logger currently imports from `src.collector.metrics` which creates a dependency on the collector package. Either:
       - Create a shared logging utility in `src/shared/logging.py`, OR
       - Use structlog directly in db.py (simpler)
       Choose the simpler approach: replace `from src.collector.metrics import get_logger` with direct `structlog.get_logger()` call. This makes `src/shared/` truly shared between collector and api packages.

    5. Create `src/api/errors.py`:
       - Define `KalshiBookError(Exception)` base class with `code`, `message`, `status` fields
       - Define specific errors: `InvalidApiKeyError`, `RateLimitExceededError`, `MarketNotFoundError`, `NoDataAvailableError`, `InvalidTimestampError`, `ValidationError`
       - Create a `generate_request_id()` function using `uuid.uuid4().hex[:12]` with `req_` prefix
       - Register FastAPI exception handlers:
         - `KalshiBookError` -> JSON envelope `{"error": {"code": "...", "message": "...", "status": N}, "request_id": "..."}`
         - `RequestValidationError` -> 422 with `validation_error` code
         - `RateLimitExceeded` (from slowapi) -> 429 with `rate_limit_exceeded` code and Retry-After header
         - Generic `Exception` -> 500 with `internal_error` code
       - Use `request.state.request_id` if available, otherwise generate new one
       - Export a `register_exception_handlers(app)` function

    6. Create `src/api/models.py` — all Pydantic v2 models:
       ```python
       # Request models
       class OrderbookRequest(BaseModel):
           market_ticker: str
           timestamp: datetime  # ISO 8601
           depth: int | None = None  # Optional: limit number of price levels

       class DeltasRequest(BaseModel):
           market_ticker: str
           start_time: datetime
           end_time: datetime
           cursor: str | None = None
           limit: int = Field(default=100, ge=1, le=1000)

       # Response models
       class OrderbookLevel(BaseModel):
           price: int = Field(description="Price in cents (1-99)")
           quantity: int = Field(description="Total contracts at this price level")

       class OrderbookResponse(BaseModel):
           market_ticker: str
           timestamp: str  # ISO 8601
           snapshot_basis: str  # ISO 8601 of underlying snapshot
           deltas_applied: int
           yes: list[OrderbookLevel]
           no: list[OrderbookLevel]
           request_id: str
           response_time: float

       class DeltaRecord(BaseModel):
           market_ticker: str
           ts: str  # ISO 8601
           seq: int
           price_cents: int
           delta_amount: int
           side: str  # "yes" or "no"

       class DeltasResponse(BaseModel):
           data: list[DeltaRecord]
           next_cursor: str | None
           has_more: bool
           request_id: str
           response_time: float

       class MarketSummary(BaseModel):
           ticker: str
           title: str | None
           event_ticker: str | None
           status: str
           category: str | None
           first_data_at: str | None  # ISO 8601
           last_data_at: str | None  # ISO 8601

       class MarketDetail(MarketSummary):
           rules: str | None
           strike_price: float | None
           discovered_at: str
           metadata: dict | None
           snapshot_count: int
           delta_count: int

       class MarketsResponse(BaseModel):
           data: list[MarketSummary]
           request_id: str
           response_time: float

       class MarketDetailResponse(BaseModel):
           data: MarketDetail
           request_id: str
           response_time: float

       # Auth/Key models
       class ApiKeyCreate(BaseModel):
           name: str = Field(default="Default", max_length=100)

       class ApiKeyCreated(BaseModel):
           id: str
           key: str  # Raw key shown ONCE
           name: str
           key_prefix: str
           created_at: str

       class ApiKeyInfo(BaseModel):
           id: str
           name: str
           key_prefix: str
           created_at: str
           last_used_at: str | None

       class ApiKeysResponse(BaseModel):
           data: list[ApiKeyInfo]
           request_id: str

       class ApiKeyCreatedResponse(BaseModel):
           data: ApiKeyCreated
           request_id: str

       class SignupRequest(BaseModel):
           email: str
           password: str = Field(min_length=8)

       class LoginRequest(BaseModel):
           email: str
           password: str

       class AuthResponse(BaseModel):
           access_token: str
           refresh_token: str
           user_id: str
           request_id: str

       # Error model (for OpenAPI spec)
       class ErrorDetail(BaseModel):
           code: str
           message: str
           status: int

       class ErrorResponse(BaseModel):
           error: ErrorDetail
           request_id: str
       ```

    7. Create `src/api/main.py`:
       - Import and use `asynccontextmanager` for lifespan
       - In lifespan: call `create_pool()` from `src.shared.db`, store pool in `app.state.pool`. On shutdown call `close_pool()`.
       - Create FastAPI app with title="KalshiBook API", description, lifespan
       - Add CORS middleware (allow all origins for now)
       - Set up SlowAPI limiter with `key_func` that extracts API key from Authorization header (fall back to IP)
       - Add SlowAPIMiddleware
       - Register exception handlers via `register_exception_handlers(app)`
       - Add middleware to inject `request_id` into `request.state` for every request
       - Add `GET /health` endpoint returning `{"status": "ok"}`
       - Include routers from routes modules (orderbook, deltas, markets, keys, auth) — these modules don't exist yet, so use conditional imports with try/except or import all routers directly. Preferred approach: import all routers unconditionally (Plans 02/03 will create the files before running).

       Router includes:
       ```python
       from src.api.routes import orderbook, deltas, markets, keys
       app.include_router(orderbook.router)
       app.include_router(deltas.router)
       app.include_router(markets.router)
       app.include_router(keys.router)
       ```

       BUT since these modules don't exist yet, register them with lazy imports or create stub route files. **Best approach:** Create minimal stub route files in this task with just the router definition and a placeholder comment. Plans 02 and 03 will replace the content.

       Create stub files:
       - `src/api/routes/orderbook.py` with `router = APIRouter(tags=["Orderbook"])`
       - `src/api/routes/deltas.py` with `router = APIRouter(tags=["Deltas"])`
       - `src/api/routes/markets.py` with `router = APIRouter(tags=["Markets"])`
       - `src/api/routes/keys.py` with `router = APIRouter(tags=["API Keys"])`
  </action>
  <verify>
    - `uv run python -c "from src.api.main import app; print(app.title)"` outputs "KalshiBook API"
    - `uv run python -c "from src.api.models import OrderbookRequest, ErrorResponse; print('OK')"` succeeds
    - `uv run python -c "from src.api.errors import KalshiBookError, register_exception_handlers; print('OK')"` succeeds
    - Start the app briefly: `timeout 5 uv run uvicorn src.api.main:app --host 0.0.0.0 --port 8000` then `curl http://localhost:8000/health` returns `{"status": "ok"}`
    - `uv run ruff check src/api/` passes (no lint errors)
  </verify>
  <done>
    FastAPI app starts, serves /health, has structured error handling, all Pydantic models defined, stub routes registered, request_id middleware active.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create auth service and API key dependency</name>
  <files>
    src/api/services/__init__.py
    src/api/services/auth.py
    src/api/deps.py
  </files>
  <action>
    1. Create `src/api/services/__init__.py` (empty).

    2. Create `src/api/services/auth.py`:
       - `generate_api_key() -> tuple[str, str]`: Generate `kb-` prefixed key using `secrets.token_urlsafe(32)`, return `(raw_key, sha256_hash)`.
       - `hash_api_key(raw_key: str) -> str`: SHA-256 hash of raw key.
       - `async create_api_key(pool, user_id: str, name: str = "Default") -> dict`: Insert into api_keys table, return dict with id, raw key, name, prefix, created_at.
       - `async validate_api_key(pool, raw_key: str) -> dict | None`: Hash the key, look up in api_keys WHERE key_hash matches AND revoked_at IS NULL. If found, update last_used_at. Return key record dict (id, user_id, name, rate_limit) or None.
       - `async list_api_keys(pool, user_id: str) -> list[dict]`: List all non-revoked keys for a user (return id, name, key_prefix, created_at, last_used_at).
       - `async revoke_api_key(pool, key_id: str, user_id: str) -> bool`: Set revoked_at = now() WHERE id = key_id AND user_id = user_id. Return True if updated, False if not found.
       - Use `hmac.compare_digest()` for constant-time hash comparison in validate_api_key (per research pitfall #2).

    3. Create `src/api/deps.py`:
       - `async def get_db_pool(request: Request) -> asyncpg.Pool`: Return `request.app.state.pool`. This is a FastAPI dependency.
       - `async def get_api_key(request: Request, pool = Depends(get_db_pool)) -> dict`: Extract Authorization header, validate "Bearer kb-..." format, call `validate_api_key()`. On failure, raise `InvalidApiKeyError` (from errors.py). On success, return key record dict.
       - `async def get_supabase_client(request: Request)`: Return Supabase admin client from `request.app.state.supabase` (will be initialized in lifespan). For now, check if `supabase` attribute exists on `app.state`.

       The `get_api_key` dependency is what all authenticated endpoints will use:
       ```python
       @router.post("/orderbook")
       async def get_orderbook(req: OrderbookRequest, key: dict = Depends(get_api_key)):
           ...
       ```

       Authorization header format per user decision: `Authorization: Bearer kb-...`
  </action>
  <verify>
    - `uv run python -c "from src.api.services.auth import generate_api_key, hash_api_key; k, h = generate_api_key(); assert k.startswith('kb-'); assert len(h) == 64; print('OK')"` succeeds
    - `uv run python -c "from src.api.deps import get_api_key, get_db_pool; print('OK')"` succeeds
    - `uv run ruff check src/api/` passes
  </verify>
  <done>
    API key generation produces kb- prefixed keys. SHA-256 hashing works. Auth dependency extracts and validates Bearer tokens. All auth CRUD operations (create, validate, list, revoke) implemented against api_keys table.
  </done>
</task>

</tasks>

<verification>
1. `uv run uvicorn src.api.main:app --host 0.0.0.0 --port 8000` starts without errors
2. `curl http://localhost:8000/health` returns `{"status": "ok"}`
3. `curl http://localhost:8000/openapi.json` returns valid OpenAPI spec
4. `curl http://localhost:8000/docs` loads Swagger UI
5. `curl -X POST http://localhost:8000/orderbook` returns structured error (401 or 422, not 500)
6. All imports resolve: `uv run python -c "from src.api.main import app; from src.api.deps import get_api_key; from src.api.services.auth import generate_api_key"`
7. `uv run ruff check src/` passes
</verification>

<success_criteria>
- FastAPI app runs and serves health check
- Structured error envelope returns for all error cases
- API key generation, hashing, and validation work correctly
- api_keys migration applied to database
- All Pydantic models importable and valid
- All route stubs registered (endpoints return 405 or empty until Plans 02/03)
- Shared config and DB modules updated for API use without breaking collector
</success_criteria>

<output>
After completion, create `.planning/phases/02-rest-api-authentication/02-01-SUMMARY.md`
</output>
