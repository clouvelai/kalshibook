---
phase: 02-rest-api-authentication
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/api/routes/orderbook.py
  - src/api/routes/deltas.py
  - src/api/routes/markets.py
  - src/api/services/__init__.py
  - src/api/services/reconstruction.py
autonomous: true

must_haves:
  truths:
    - "User can POST /orderbook with market_ticker and timestamp and receive reconstructed bid/ask levels"
    - "User can POST /deltas with market_ticker and time range and receive paginated delta records"
    - "User can GET /markets and receive a list of markets with data coverage dates"
    - "User can GET /markets/{ticker} and receive full market metadata with snapshot/delta counts"
    - "Requesting orderbook at timestamp before any snapshot returns structured error with earliest available timestamp"
    - "All data endpoints require valid API key in Authorization: Bearer header"
  artifacts:
    - path: "src/api/services/reconstruction.py"
      provides: "Orderbook reconstruction algorithm: snapshot + delta replay"
      contains: "reconstruct_orderbook"
    - path: "src/api/routes/orderbook.py"
      provides: "POST /orderbook endpoint"
      contains: "router"
    - path: "src/api/routes/deltas.py"
      provides: "POST /deltas endpoint with cursor pagination"
      contains: "router"
    - path: "src/api/routes/markets.py"
      provides: "GET /markets and GET /markets/{ticker} endpoints"
      contains: "router"
  key_links:
    - from: "src/api/routes/orderbook.py"
      to: "src/api/services/reconstruction.py"
      via: "endpoint calls reconstruct_orderbook"
      pattern: "reconstruct_orderbook"
    - from: "src/api/services/reconstruction.py"
      to: "snapshots table + deltas table"
      via: "SQL queries via asyncpg pool"
      pattern: "SELECT.*FROM snapshots"
    - from: "src/api/routes/deltas.py"
      to: "deltas table"
      via: "cursor-based SQL query"
      pattern: "SELECT.*FROM deltas"
    - from: "src/api/routes/markets.py"
      to: "markets + snapshots + deltas tables"
      via: "SQL queries for metadata and coverage dates"
      pattern: "SELECT.*FROM markets"
---

<objective>
Implement the three data-serving endpoints: orderbook reconstruction, raw delta queries, and market listing/metadata. These are the core value endpoints -- they serve the historical orderbook data that Phase 1 collected.

Purpose: Enable users to query reconstructed orderbook state at any timestamp, browse raw deltas for backtesting, and discover available markets with coverage dates.
Output: Three working endpoints (POST /orderbook, POST /deltas, GET /markets, GET /markets/{ticker}) all requiring API key auth and returning structured responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rest-api-authentication/02-RESEARCH.md
@.planning/phases/02-rest-api-authentication/02-CONTEXT.md
@.planning/phases/02-rest-api-authentication/02-01-SUMMARY.md

@supabase/migrations/20260213000001_create_markets.sql
@supabase/migrations/20260213000002_create_snapshots.sql
@supabase/migrations/20260213000003_create_deltas.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement orderbook reconstruction service and endpoint</name>
  <files>
    src/api/services/reconstruction.py
    src/api/routes/orderbook.py
  </files>
  <action>
    1. Create `src/api/services/reconstruction.py`:

       `async def reconstruct_orderbook(pool, market_ticker: str, at_timestamp: datetime, depth: int | None = None) -> dict | None`:

       **Algorithm (from RESEARCH.md Pattern 4):**
       - Step 1: Query most recent snapshot before `at_timestamp` for this market:
         ```sql
         SELECT captured_at, seq, yes_levels, no_levels
         FROM snapshots
         WHERE market_ticker = $1 AND captured_at <= $2
         ORDER BY captured_at DESC LIMIT 1
         ```
       - Step 2: If no snapshot found, query the EARLIEST snapshot for this market (to provide the `earliest_available_at` in error):
         ```sql
         SELECT captured_at FROM snapshots
         WHERE market_ticker = $1
         ORDER BY captured_at ASC LIMIT 1
         ```
         Return `{"error": "no_data", "earliest_available_at": earliest.isoformat()}` or None if no data at all.

       - Step 3: Fetch all deltas between snapshot and target timestamp:
         ```sql
         SELECT price_cents, delta_amount, side, seq
         FROM deltas
         WHERE market_ticker = $1 AND ts > $2 AND ts <= $3
         ORDER BY seq ASC
         ```

       - Step 4: Apply deltas to snapshot levels.
         The snapshot's `yes_levels` and `no_levels` are JSONB arrays of `[price_cents, quantity]` pairs.
         Convert to dicts `{price: quantity}`, iterate deltas, apply delta_amount to correct side/price.
         If quantity reaches 0 or below, remove the level.

       - Step 5: Sort levels by price descending. If `depth` is provided, return only top N levels per side.

       - Step 6: Return dict with: `market_ticker`, `timestamp` (ISO string), `snapshot_basis` (ISO string), `deltas_applied` (int), `yes` (list of {price, quantity}), `no` (list of {price, quantity}).

       `async def get_earliest_snapshot_time(pool, market_ticker: str) -> datetime | None`:
       Helper to find the earliest snapshot timestamp for a market. Used for error messages.

       **Important:** The `yes_levels`/`no_levels` JSONB in the snapshots table stores arrays of `[price_cents, quantity]`. asyncpg returns JSONB as Python dicts/lists automatically via json deserialization. Parse with orjson if needed for performance.

    2. Replace stub `src/api/routes/orderbook.py` with full implementation:

       ```python
       router = APIRouter(tags=["Orderbook"])

       @router.post("/orderbook", response_model=OrderbookResponse)
       @limiter.limit("100/minute")  # Use rate limiter
       async def get_orderbook(
           request: Request,
           body: OrderbookRequest,
           key: dict = Depends(get_api_key),
           pool: asyncpg.Pool = Depends(get_db_pool),
       ):
       ```

       - Call `reconstruct_orderbook(pool, body.market_ticker, body.timestamp, body.depth)`
       - If result is None (no market data at all), raise `MarketNotFoundError`
       - If result has `error: "no_data"`, raise `NoDataAvailableError` with earliest_available_at in message
       - On success, return `OrderbookResponse` with all fields + request_id from request.state + response_time (measured with time.monotonic())

       Rate limiting: Apply `@limiter.limit()` decorator. The rate limit key function in main.py already extracts API key from header.

       Important: Import `limiter` from `src.api.main` — OR access via `request.app.state.limiter`. The SlowAPI decorator approach requires the limiter instance at import time. Alternative: Access the limiter via `request.app.state.limiter` and use `@limiter.shared_limit()`. Check how SlowAPI works with FastAPI routers — the standard pattern is to create the limiter in main.py and import it in route files.

       **Recommended approach:** Create the limiter in a separate module (e.g., reuse `deps.py` or create `src/api/limiter.py`) so routes can import it without circular imports. Or simply define it at module level in main.py and import from there. Since main.py already creates the limiter, import it: `from src.api.main import limiter`.

       Actually, the cleanest approach to avoid circular imports: define the limiter in `deps.py` (which has no route imports) and import it in both `main.py` (to add middleware) and route files (for decorators).
  </action>
  <verify>
    - `uv run python -c "from src.api.services.reconstruction import reconstruct_orderbook; print('OK')"` succeeds
    - Start app, then test:
      - `curl -X POST http://localhost:8000/orderbook -H "Content-Type: application/json" -d '{"market_ticker":"TEST","timestamp":"2026-02-14T00:00:00Z"}'` returns 401 (no auth)
      - With valid API key (create one via DB), returns reconstructed orderbook or appropriate error
    - `uv run ruff check src/api/` passes
  </verify>
  <done>
    POST /orderbook accepts market_ticker + timestamp, returns reconstructed orderbook state with yes/no price levels. Handles missing data, timestamps before first snapshot, and non-existent markets with structured errors. Rate limited. Requires auth.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement deltas and markets endpoints</name>
  <files>
    src/api/routes/deltas.py
    src/api/routes/markets.py
  </files>
  <action>
    1. Replace stub `src/api/routes/deltas.py` with full implementation:

       ```python
       router = APIRouter(tags=["Deltas"])

       @router.post("/deltas", response_model=DeltasResponse)
       ```

       **Cursor-based pagination (from RESEARCH.md Pattern 5):**
       - Parse `cursor` from request body. If present, base64-decode it to get `(ts, id)` tuple.
       - Cursor encoding: `base64(json({"ts": "ISO8601", "id": int}))` — use orjson for speed.

       - First page query:
         ```sql
         SELECT id, market_ticker, ts, seq, price_cents, delta_amount, side
         FROM deltas
         WHERE market_ticker = $1 AND ts >= $2 AND ts <= $3
         ORDER BY ts ASC, id ASC
         LIMIT $4
         ```

       - Subsequent page query (with cursor):
         ```sql
         SELECT id, market_ticker, ts, seq, price_cents, delta_amount, side
         FROM deltas
         WHERE market_ticker = $1 AND ts >= $2 AND ts <= $3
           AND (ts, id) > ($5, $6)
         ORDER BY ts ASC, id ASC
         LIMIT $4
         ```

       - Fetch `limit + 1` rows to determine `has_more`. If got `limit + 1` rows, set `has_more = True` and drop the last row. Encode last row's `(ts, id)` as `next_cursor`.
       - Return `DeltasResponse` with data, next_cursor, has_more, request_id, response_time.
       - Requires auth via `Depends(get_api_key)`.

    2. Replace stub `src/api/routes/markets.py` with full implementation:

       ```python
       router = APIRouter(tags=["Markets"])

       @router.get("/markets", response_model=MarketsResponse)
       ```

       **GET /markets** — list all markets with coverage dates:
       - Query markets table joined with subqueries for first/last data timestamps:
         ```sql
         SELECT m.ticker, m.title, m.event_ticker, m.status, m.category,
           (SELECT MIN(captured_at) FROM snapshots WHERE market_ticker = m.ticker) AS first_data_at,
           (SELECT MAX(ts) FROM deltas WHERE market_ticker = m.ticker) AS last_data_at
         FROM markets m
         ORDER BY m.discovered_at DESC
         ```
       - NOTE: The correlated subqueries on snapshots/deltas may be slow for many markets. For MVP this is acceptable — can be optimized later with materialized columns. If performance is a concern, limit to active markets.
       - Requires auth via `Depends(get_api_key)`.

       **GET /markets/{ticker}** — single market detail:
       ```python
       @router.get("/markets/{ticker}", response_model=MarketDetailResponse)
       ```
       - Query market by ticker from markets table
       - Get snapshot_count and delta_count via COUNT queries
       - Get first_data_at and last_data_at
       - If ticker not found, raise `MarketNotFoundError`
       - Requires auth via `Depends(get_api_key)`.
  </action>
  <verify>
    - Start app, then test with auth header:
      - `curl -X POST http://localhost:8000/deltas -H "Authorization: Bearer kb-testkey" -H "Content-Type: application/json" -d '{"market_ticker":"TEST","start_time":"2026-02-13T00:00:00Z","end_time":"2026-02-14T00:00:00Z"}'` returns structured response (may be empty data)
      - `curl http://localhost:8000/markets -H "Authorization: Bearer kb-testkey"` returns list of markets
      - `curl http://localhost:8000/markets/NONEXISTENT -H "Authorization: Bearer kb-testkey"` returns 404 structured error
    - `uv run ruff check src/api/` passes
  </verify>
  <done>
    POST /deltas returns paginated raw deltas with cursor-based pagination (base64-encoded ts+id cursor). GET /markets returns all markets with coverage dates. GET /markets/{ticker} returns full metadata with counts. All require auth. All return structured responses with request_id and response_time.
  </done>
</task>

</tasks>

<verification>
1. POST /orderbook with valid auth returns reconstructed orderbook for a market with data
2. POST /orderbook for nonexistent market returns `{"error": {"code": "market_not_found", ...}}`
3. POST /orderbook for timestamp before data returns `{"error": {"code": "no_data_available", ...}}` with earliest timestamp
4. POST /deltas returns paginated results with next_cursor when more data exists
5. POST /deltas with cursor returns next page of results
6. GET /markets returns list with first_data_at/last_data_at
7. GET /markets/{ticker} returns full detail with snapshot_count/delta_count
8. All endpoints return 401 without auth header
9. All responses include request_id and match documented Pydantic models
10. `uv run ruff check src/api/` passes
</verification>

<success_criteria>
- Orderbook reconstruction produces accurate state (snapshot + delta replay)
- Delta pagination works correctly with cursor encoding/decoding
- Market coverage dates are computed from actual data
- All three data endpoint groups (orderbook, deltas, markets) are functional
- Error handling is consistent (structured envelope for all error cases)
- Auth is enforced on every endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/02-rest-api-authentication/02-02-SUMMARY.md`
</output>
