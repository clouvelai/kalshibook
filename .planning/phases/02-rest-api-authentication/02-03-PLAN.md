---
phase: 02-rest-api-authentication
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/api/routes/keys.py
  - src/api/routes/auth.py
  - src/api/main.py
  - static/llms.txt
  - static/llms-full.txt
autonomous: true
user_setup:
  - service: supabase
    why: "User authentication via Supabase Auth (signup/login)"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Settings -> API -> Project URL"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Settings -> API -> Service Role Key"
    dashboard_config:
      - task: "Ensure email auth is enabled"
        location: "Supabase Dashboard -> Authentication -> Providers -> Email"

must_haves:
  truths:
    - "User can POST /auth/signup with email and password to create a Supabase account"
    - "User can POST /auth/login with email and password to receive access and refresh tokens"
    - "Authenticated user can POST /keys to create an API key and receive the raw key once"
    - "Authenticated user can GET /keys to list their API keys (prefix only, not raw key)"
    - "Authenticated user can DELETE /keys/{id} to revoke an API key"
    - "/llms.txt returns markdown discovery file for AI agents"
    - "/llms-full.txt returns detailed API description for AI agents"
    - "Rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset) appear in responses"
  artifacts:
    - path: "src/api/routes/keys.py"
      provides: "API key CRUD endpoints (create, list, revoke)"
      contains: "router"
    - path: "src/api/routes/auth.py"
      provides: "Auth proxy endpoints (signup, login)"
      contains: "router"
    - path: "static/llms.txt"
      provides: "AI agent discovery file"
      contains: "KalshiBook API"
    - path: "static/llms-full.txt"
      provides: "Detailed AI agent API reference"
      contains: "KalshiBook API"
  key_links:
    - from: "src/api/routes/keys.py"
      to: "src/api/services/auth.py"
      via: "endpoints call create_api_key, list_api_keys, revoke_api_key"
      pattern: "create_api_key"
    - from: "src/api/routes/auth.py"
      to: "supabase client"
      via: "signup/login proxy to Supabase Auth"
      pattern: "sign_up|sign_in"
    - from: "src/api/main.py"
      to: "static/llms.txt"
      via: "static file mount or dedicated route"
      pattern: "llms"
---

<objective>
Implement authentication proxy endpoints (signup/login via Supabase), API key management endpoints (create/list/revoke), Supabase client initialization, rate limiting wiring, and AI agent discovery files (llms.txt).

Purpose: Enable users to create accounts, generate API keys, and manage access. Provide AI agent discoverability via llms.txt. Complete the auth and developer experience requirements.
Output: Working auth flow (signup -> login -> create key -> use key), rate limiting with headers, llms.txt served.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-rest-api-authentication/02-RESEARCH.md
@.planning/phases/02-rest-api-authentication/02-CONTEXT.md
@.planning/phases/02-rest-api-authentication/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement auth proxy and key management endpoints</name>
  <files>
    src/api/routes/auth.py
    src/api/routes/keys.py
    src/api/main.py
  </files>
  <action>
    1. Create `src/api/routes/auth.py` — Supabase Auth proxy endpoints:

       ```python
       router = APIRouter(tags=["Authentication"])
       ```

       **POST /auth/signup** — Create a new user account:
       - Accept `SignupRequest` (email, password)
       - Get Supabase admin client from `request.app.state.supabase`
       - Call `supabase.auth.sign_up({"email": email, "password": password})`
       - On success, return `AuthResponse` with access_token, refresh_token, user_id
       - On error (duplicate email, weak password), return structured error with appropriate code
       - NO rate limiting by API key (user doesn't have one yet). Rate limit by IP instead.
       - Do NOT require API key auth (this is a public endpoint)

       **POST /auth/login** — Authenticate and get tokens:
       - Accept `LoginRequest` (email, password)
       - Call `supabase.auth.sign_in_with_password({"email": email, "password": password})`
       - On success, return `AuthResponse`
       - On error (wrong credentials), return structured error
       - Public endpoint (no API key required)

       **Important Supabase client notes:**
       - Use the async Supabase client: `from supabase import acreate_client, AsyncClient`
       - Initialize in `main.py` lifespan: `supabase_client = await acreate_client(url, key)`
       - Store as `app.state.supabase`
       - The service_role key gives admin access (can create users, bypass RLS)

    2. Replace stub `src/api/routes/keys.py` with full implementation:

       ```python
       router = APIRouter(tags=["API Keys"])
       ```

       **POST /keys** — Create a new API key:
       - Requires auth: user must provide Supabase access_token in `Authorization: Bearer <jwt>` header
       - BUT this conflicts with API key auth pattern (same header, different token format)
       - **Resolution:** Key management uses Supabase JWT auth (not API key auth). Create a separate dependency `get_authenticated_user` that validates Supabase JWTs. Use this for /keys endpoints.
       - Accept `ApiKeyCreate` body (name field)
       - Call `create_api_key(pool, user_id, name)` from auth service
       - Return `ApiKeyCreatedResponse` with the raw key (shown ONCE)

       **GET /keys** — List user's API keys:
       - Requires Supabase JWT auth (same `get_authenticated_user` dependency)
       - Call `list_api_keys(pool, user_id)` from auth service
       - Return `ApiKeysResponse` with list of keys (prefix only, never raw key)

       **DELETE /keys/{key_id}** — Revoke an API key:
       - Requires Supabase JWT auth
       - Call `revoke_api_key(pool, key_id, user_id)` from auth service
       - If not found or not owned by user, return 404
       - Return `{"message": "API key revoked", "request_id": "..."}`

       **Supabase JWT auth dependency** — add to `src/api/deps.py`:
       ```python
       async def get_authenticated_user(request: Request) -> dict:
           """Validate Supabase JWT and return user info. For key management endpoints."""
           auth_header = request.headers.get("Authorization", "")
           if not auth_header.startswith("Bearer "):
               raise InvalidApiKeyError("Missing Bearer token")
           token = auth_header.removeprefix("Bearer ").strip()
           # Supabase JWT tokens don't start with "kb-"
           if token.startswith("kb-"):
               raise KalshiBookError(
                   code="invalid_auth_method",
                   message="Key management endpoints require a Supabase access token, not an API key. Use POST /auth/login to get an access token.",
                   status=401
               )
           # Validate JWT via Supabase
           supabase = request.app.state.supabase
           user = await supabase.auth.get_user(token)
           if user is None:
               raise InvalidApiKeyError("Invalid or expired access token")
           return {"user_id": str(user.user.id), "email": user.user.email}
       ```

    3. Update `src/api/main.py`:
       - In lifespan, initialize Supabase async client:
         ```python
         from supabase import acreate_client
         settings = get_settings()
         supabase = await acreate_client(settings.supabase_url, settings.supabase_service_role_key)
         app.state.supabase = supabase
         ```
       - Include the auth router: `app.include_router(auth.router)` — add import
       - Note: main.py was created in Plan 01 with stub router imports. Now add the auth router import.
  </action>
  <verify>
    - `uv run python -c "from src.api.routes.auth import router; from src.api.routes.keys import router; print('OK')"` succeeds
    - Start app with Supabase running locally:
      - `curl -X POST http://localhost:8000/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"testpass123"}'` returns tokens or error
      - `curl -X POST http://localhost:8000/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"testpass123"}'` returns tokens
      - Use access_token to: `curl -X POST http://localhost:8000/keys -H "Authorization: Bearer <jwt>" -H "Content-Type: application/json" -d '{"name":"My Key"}'` returns API key with kb- prefix
      - `curl http://localhost:8000/keys -H "Authorization: Bearer <jwt>"` returns key list
    - `uv run ruff check src/api/` passes
  </verify>
  <done>
    Auth proxy works: signup creates user, login returns tokens. Key management works: create returns raw key once, list shows prefixes, revoke deactivates. Supabase client initialized in lifespan. JWT auth dependency validates access tokens for key management. Clear error messages distinguish between API key auth and JWT auth.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create llms.txt discovery files and configure OpenAPI metadata</name>
  <files>
    static/llms.txt
    static/llms-full.txt
    src/api/main.py
  </files>
  <action>
    1. Create `static/llms.txt` — AI agent discovery file following llms.txt spec (https://llmstxt.org/):

       ```markdown
       # KalshiBook API

       > Historical L2 orderbook data API for Kalshi prediction markets. Query reconstructed orderbook state at any timestamp, raw deltas, and market metadata.

       KalshiBook provides programmatic access to historical Kalshi orderbook data for backtesting trading strategies and building automated trading systems.

       ## API Reference
       - [OpenAPI Spec](/openapi.json): Full API specification
       - [Interactive Docs](/docs): Swagger UI for testing endpoints
       - [ReDoc](/redoc): Alternative API documentation

       ## Endpoints
       - [POST /orderbook](/docs#/Orderbook/get_orderbook_orderbook_post): Reconstruct orderbook state at any historical timestamp
       - [POST /deltas](/docs#/Deltas/get_deltas_deltas_post): Query raw orderbook deltas by market and time range (paginated)
       - [GET /markets](/docs#/Markets/list_markets_markets_get): List available markets with data coverage dates
       - [GET /markets/{ticker}](/docs#/Markets/get_market_markets__ticker__get): Get market metadata and contract details

       ## Authentication
       All data endpoints require an API key sent as `Authorization: Bearer kb-YOUR_KEY`.

       To get an API key:
       1. Create an account: `POST /auth/signup` with `{"email": "...", "password": "..."}`
       2. Login: `POST /auth/login` with `{"email": "...", "password": "..."}`
       3. Create a key: `POST /keys` with `{"name": "My Key"}` using your access token

       ## Key Management
       - [POST /keys](/docs#/API%20Keys): Create a new API key (requires access token)
       - [GET /keys](/docs#/API%20Keys): List your API keys
       - [DELETE /keys/{id}](/docs#/API%20Keys): Revoke an API key

       ## Optional
       - [GET /health](/docs#/default/health_health_get): Health check endpoint
       ```

    2. Create `static/llms-full.txt` — detailed API reference:

       Include everything from llms.txt plus:
       - Full request/response schemas for each endpoint (JSON examples)
       - Error codes and their meanings
       - Rate limiting details
       - Pagination explanation for /deltas
       - Orderbook reconstruction explanation (how snapshot + delta replay works)
       - Example workflows: "How to backtest" (query markets -> pick market -> query orderbook at timestamps)
       - Authentication flow walkthrough

       This file should be comprehensive enough that an AI agent can integrate with KalshiBook without reading any other docs. Target ~200-300 lines of markdown.

    3. Update `src/api/main.py` to serve llms.txt files:
       - Mount static files directory: `app.mount("/static", StaticFiles(directory="static"), name="static")`
       - OR add dedicated routes (simpler for specific files):
         ```python
         from fastapi.responses import PlainTextResponse

         @app.get("/llms.txt", response_class=PlainTextResponse, include_in_schema=False)
         async def llms_txt():
             with open("static/llms.txt") as f:
                 return f.read()

         @app.get("/llms-full.txt", response_class=PlainTextResponse, include_in_schema=False)
         async def llms_full_txt():
             with open("static/llms-full.txt") as f:
                 return f.read()
         ```
       - Use `include_in_schema=False` so these don't clutter the OpenAPI spec.

    4. Enhance FastAPI OpenAPI metadata in `src/api/main.py`:
       - Ensure tags are well-defined with descriptions for OpenAPI grouping
       - Add contact info, license, terms of service to FastAPI constructor if desired
       - Verify `/openapi.json` is served (FastAPI default)
       - Verify `/docs` (Swagger UI) and `/redoc` are working

    5. Verify rate limiting produces standard headers:
       - SlowAPI with `headers_enabled=True` should produce X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset headers on all rate-limited endpoints
       - 429 responses should include Retry-After header
       - Confirm by hitting a rate-limited endpoint and inspecting response headers
  </action>
  <verify>
    - `curl http://localhost:8000/llms.txt` returns markdown content starting with "# KalshiBook API"
    - `curl http://localhost:8000/llms-full.txt` returns detailed markdown
    - `curl http://localhost:8000/openapi.json` returns valid JSON with all endpoints listed
    - `curl http://localhost:8000/docs` returns HTML (Swagger UI)
    - `curl http://localhost:8000/redoc` returns HTML (ReDoc)
    - Response headers on data endpoints include X-RateLimit-Limit, X-RateLimit-Remaining
    - `uv run ruff check src/api/` passes
  </verify>
  <done>
    /llms.txt and /llms-full.txt served as markdown discovery files for AI agents. OpenAPI spec auto-generated with tagged endpoint groups. Swagger UI at /docs and ReDoc at /redoc. Rate limit headers appear on responses. All developer experience requirements (DEVX-01 through DEVX-04) satisfied.
  </done>
</task>

</tasks>

<verification>
1. Full auth flow: signup -> login -> create key -> use key on /orderbook
2. POST /auth/signup creates user, returns tokens
3. POST /auth/login authenticates, returns tokens
4. POST /keys with JWT creates API key with kb- prefix
5. GET /keys lists keys with prefixes (no raw keys exposed)
6. DELETE /keys/{id} revokes key, subsequent API calls with that key return 401
7. /llms.txt returns valid markdown
8. /llms-full.txt returns comprehensive API reference
9. /openapi.json includes all endpoints with schemas
10. Rate limit headers present on responses
11. 429 response with Retry-After when rate limit exceeded
12. `uv run ruff check src/api/` passes
</verification>

<success_criteria>
- Complete auth flow works end-to-end (signup -> login -> create key -> use key)
- Key management CRUD operations functional
- Supabase JWT auth correctly differentiates from API key auth
- llms.txt files provide comprehensive AI agent discoverability
- OpenAPI spec auto-generated with all endpoints
- Rate limiting enforced with standard headers
- All auth and developer experience requirements met
</success_criteria>

<output>
After completion, create `.planning/phases/02-rest-api-authentication/02-03-SUMMARY.md`
</output>
