---
phase: 03-billing-monetization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260215000001_create_billing_accounts.sql
  - supabase/migrations/20260215000002_create_api_key_usage.sql
  - src/shared/config.py
  - src/api/errors.py
  - src/api/models.py
  - src/api/deps.py
  - src/api/services/billing.py
  - src/api/main.py
  - pyproject.toml
autonomous: true
user_setup:
  - service: stripe
    why: "Payment processing and usage-based billing"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Signing secret (or from `stripe listen` output for local dev)"
      - name: STRIPE_PROJECT_PRICE_ID
        source: "Stripe Dashboard -> Product catalog -> KalshiBook Project price -> Price ID (price_xxx)"
      - name: STRIPE_METER_EVENT_NAME
        source: "Stripe Dashboard -> Billing -> Meters -> Event name (default: kalshibook_api_credits)"
    dashboard_config:
      - task: "Create Product: 'KalshiBook Project' with $30/month recurring price"
        location: "Stripe Dashboard -> Product catalog -> Add product"
      - task: "Create Product: 'KalshiBook API Credits' with metered price at $0.008/unit"
        location: "Stripe Dashboard -> Product catalog -> Add product (usage-based pricing)"
      - task: "Create Meter: 'kalshibook_api_credits' with sum aggregation"
        location: "Stripe Dashboard -> Billing -> Meters -> Create meter"

must_haves:
  truths:
    - "Each API operation deducts a defined number of credits from the user's monthly allocation"
    - "Free tier users start with 1,000 credits/month and can use the API without payment info"
    - "When credits are exhausted (non-PAYG), API requests return 429 with a clear error message"
    - "Remaining credits are reported in X-Credits-Remaining header on every API response"
    - "Per-API-key usage is tracked (endpoint + credits charged)"
    - "Rate limits vary by tier (Free: 30/min, PAYG: 60/min, Project: 120/min)"
  artifacts:
    - path: "supabase/migrations/20260215000001_create_billing_accounts.sql"
      provides: "Billing accounts table with tier, credits, PAYG flag, Stripe mapping"
      contains: "billing_accounts"
    - path: "supabase/migrations/20260215000002_create_api_key_usage.sql"
      provides: "Per-key usage tracking table"
      contains: "api_key_usage"
    - path: "src/api/services/billing.py"
      provides: "Credit deduction, billing account upsert, usage logging, Stripe meter reporting"
      exports: ["ensure_billing_account", "deduct_credits", "log_key_usage", "report_stripe_usage"]
    - path: "src/api/deps.py"
      provides: "require_credits dependency factory chaining after get_api_key"
      contains: "require_credits"
    - path: "src/api/errors.py"
      provides: "CreditsExhaustedError (429)"
      contains: "CreditsExhaustedError"
  key_links:
    - from: "src/api/deps.py"
      to: "src/api/services/billing.py"
      via: "require_credits calls deduct_credits"
      pattern: "deduct_credits"
    - from: "src/api/deps.py"
      to: "src/api/deps.py"
      via: "require_credits chains after get_api_key via Depends"
      pattern: "Depends\\(get_api_key\\)"
    - from: "src/api/main.py"
      to: "src/api/deps.py"
      via: "credit headers middleware reads request.state credit info"
      pattern: "credits_remaining"
    - from: "src/api/routes/orderbook.py"
      to: "src/api/deps.py"
      via: "endpoint uses require_credits(5)"
      pattern: "require_credits\\(5\\)"
---

<objective>
Credit metering infrastructure: database tables, billing service, require_credits dependency, credit headers middleware, CreditsExhaustedError, tier-aware rate limiting, and integration with all existing data endpoints.

Purpose: Every API request must deduct credits and enforce limits before Phase 3 Stripe integration can bill for overages.
Output: Working credit system where free-tier users get 1,000 credits/month, each endpoint costs defined credits, exhausted users get 429, and per-key usage is tracked.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-billing-monetization/03-RESEARCH.md

@src/api/deps.py
@src/api/errors.py
@src/api/main.py
@src/api/models.py
@src/shared/config.py
@src/api/routes/orderbook.py
@src/api/routes/deltas.py
@src/api/routes/markets.py
@supabase/migrations/20260214000001_create_api_keys.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema, billing service, and configuration</name>
  <files>
    supabase/migrations/20260215000001_create_billing_accounts.sql
    supabase/migrations/20260215000002_create_api_key_usage.sql
    src/api/services/billing.py
    src/shared/config.py
    src/api/errors.py
    src/api/models.py
    pyproject.toml
  </files>
  <action>
**Migrations:**

Create `supabase/migrations/20260215000001_create_billing_accounts.sql`:
```sql
CREATE TABLE IF NOT EXISTS billing_accounts (
    user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    stripe_customer_id TEXT UNIQUE,
    tier TEXT NOT NULL DEFAULT 'free' CHECK (tier IN ('free', 'payg', 'project')),
    payg_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    credits_total INT NOT NULL DEFAULT 1000,
    credits_used INT NOT NULL DEFAULT 0,
    billing_cycle_start TIMESTAMPTZ NOT NULL DEFAULT date_trunc('month', now()),
    stripe_subscription_id TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_billing_accounts_stripe ON billing_accounts (stripe_customer_id) WHERE stripe_customer_id IS NOT NULL;
```

Create `supabase/migrations/20260215000002_create_api_key_usage.sql`:
```sql
CREATE TABLE IF NOT EXISTS api_key_usage (
    id BIGSERIAL PRIMARY KEY,
    api_key_id UUID NOT NULL REFERENCES api_keys(id) ON DELETE CASCADE,
    endpoint TEXT NOT NULL,
    credits_charged INT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX idx_api_key_usage_key_time ON api_key_usage (api_key_id, created_at DESC);
```

**Billing service** (`src/api/services/billing.py`):

Implement the following functions:
- `ensure_billing_account(pool, user_id) -> dict`: Upsert a billing_accounts row with free-tier defaults (1000 credits). Uses `INSERT ... ON CONFLICT (user_id) DO UPDATE SET updated_at = now() RETURNING *`.
- `lazy_reset_credits(pool, user_id)`: Check if billing_cycle_start is in a previous month; if so, atomically reset credits_used to 0 and advance billing_cycle_start to `date_trunc('month', now())`. Idempotent.
- `deduct_credits(pool, user_id, cost) -> dict | None`: First call lazy_reset_credits. Then atomically `UPDATE billing_accounts SET credits_used = credits_used + $cost WHERE user_id = $user_id AND (credits_used + $cost <= credits_total OR payg_enabled = TRUE) RETURNING user_id, tier, credits_total, credits_used, payg_enabled`. Return dict if successful, None if insufficient.
- `log_key_usage(pool, api_key_id, endpoint, credits_charged)`: INSERT into api_key_usage. Fire-and-forget (exceptions logged, not raised).
- `report_stripe_usage(stripe_customer_id, credits, event_name)`: Report PAYG overage to Stripe Meter API via `stripe.billing.MeterEvent.create_async(event_name=event_name, payload={"stripe_customer_id": stripe_customer_id, "value": str(credits)})`. Fire-and-forget with error logging. Import stripe at module level. Only called when payg_enabled AND credits_used > credits_total.

Use `structlog.get_logger("api.billing")` for all logging. Use `asyncpg.Pool` type for pool parameter. Keep functions standalone (no class) following existing service pattern in `src/api/services/auth.py`.

**Config** (`src/shared/config.py`):

Add these fields to the Settings class:
- `stripe_secret_key: str = ""` -- Stripe secret API key
- `stripe_webhook_secret: str = ""` -- Stripe webhook signing secret
- `stripe_project_price_id: str = ""` -- Stripe Price ID for Project plan
- `stripe_meter_event_name: str = "kalshibook_api_credits"` -- Stripe Meter event name
- `app_url: str = "http://localhost:3000"` -- Frontend URL for Stripe redirect URLs

**Errors** (`src/api/errors.py`):

Add `CreditsExhaustedError` class following existing pattern:
```python
class CreditsExhaustedError(KalshiBookError):
    def __init__(self):
        super().__init__(
            code="credits_exhausted",
            message=(
                "Monthly credit limit reached. Enable Pay-As-You-Go for continued "
                "access or upgrade to the Project plan at /billing/checkout."
            ),
            status=429,
        )
```

**Models** (`src/api/models.py`):

Add billing-related response models:
- `BillingStatusResponse`: tier, credits_total, credits_used, credits_remaining, payg_enabled, billing_cycle_start, request_id
- `PaygToggleRequest`: enable (bool)
- `PaygToggleResponse`: payg_enabled (bool), message (str), request_id (str)
- `CheckoutResponse`: checkout_url (str), request_id (str)
- `PortalResponse`: portal_url (str), request_id (str)

**Dependencies** (`pyproject.toml`):

Add `"stripe[async]>=14.3.0"` to the dependencies list.
  </action>
  <verify>
Run `supabase db reset` (or apply migrations) and verify both tables exist:
```bash
supabase db reset
```
Verify Python imports work:
```bash
uv run python -c "from src.api.services.billing import ensure_billing_account, deduct_credits, log_key_usage, report_stripe_usage; print('OK')"
uv run python -c "from src.api.errors import CreditsExhaustedError; print('OK')"
uv run python -c "from src.api.models import BillingStatusResponse, PaygToggleRequest; print('OK')"
uv run python -c "import stripe; print(f'stripe {stripe.VERSION}')"
```
  </verify>
  <done>
billing_accounts and api_key_usage tables created via migrations. Billing service has ensure_billing_account, deduct_credits (atomic), lazy_reset_credits, log_key_usage, report_stripe_usage. CreditsExhaustedError returns 429 with clear message. Billing models exist. stripe[async] installed. Config has all Stripe env vars.
  </done>
</task>

<task type="auto">
  <name>Task 2: Credit dependency, headers middleware, tier-aware rate limits, and endpoint integration</name>
  <files>
    src/api/deps.py
    src/api/main.py
    src/api/routes/orderbook.py
    src/api/routes/deltas.py
    src/api/routes/markets.py
  </files>
  <action>
**require_credits dependency** (`src/api/deps.py`):

Add a `require_credits(cost: int)` dependency factory. This is the core metering hook.

```python
import asyncio
from src.api.services.billing import (
    ensure_billing_account, deduct_credits, log_key_usage, report_stripe_usage
)
from src.api.errors import CreditsExhaustedError

CREDIT_COSTS = {
    "markets": 1,
    "market_detail": 1,
    "deltas": 2,
    "orderbook": 5,
}

def require_credits(cost: int):
    """Factory returning a dependency that deducts `cost` credits."""
    async def _check_credits(
        request: Request,
        key: dict = Depends(get_api_key),
        pool: asyncpg.Pool = Depends(get_db_pool),
    ) -> dict:
        user_id = key["user_id"]

        # Ensure billing account exists (lazy upsert on first request)
        await ensure_billing_account(pool, user_id)

        # Atomic credit deduction
        row = await deduct_credits(pool, user_id, cost)
        if row is None:
            raise CreditsExhaustedError()

        credits_remaining = max(0, row["credits_total"] - row["credits_used"])

        # Store credit info on request.state for response headers
        request.state.credits_remaining = credits_remaining
        request.state.credits_used = row["credits_used"]
        request.state.credits_total = row["credits_total"]
        request.state.credits_cost = cost

        # If PAYG and over allocation, report overage to Stripe (fire-and-forget)
        if row["payg_enabled"] and row["credits_used"] > row["credits_total"]:
            billing = await pool.fetchrow(
                "SELECT stripe_customer_id FROM billing_accounts WHERE user_id = $1",
                user_id,
            )
            if billing and billing["stripe_customer_id"]:
                settings = get_settings()
                asyncio.create_task(
                    report_stripe_usage(
                        billing["stripe_customer_id"], cost, settings.stripe_meter_event_name
                    )
                )

        # Log per-key usage (fire-and-forget)
        asyncio.create_task(log_key_usage(pool, key["id"], request.url.path, cost))

        return {**key, "tier": row["tier"]}

    return _check_credits
```

Import `get_settings` from `src.shared.config` at top of file.

**Credit headers middleware** (`src/api/main.py`):

Add a new middleware AFTER the existing request ID middleware:

```python
@app.middleware("http")
async def inject_credit_headers(request: Request, call_next):
    """Add credit usage headers to every API response."""
    response = await call_next(request)
    if hasattr(request.state, "credits_remaining"):
        response.headers["X-Credits-Remaining"] = str(request.state.credits_remaining)
        response.headers["X-Credits-Used"] = str(request.state.credits_used)
        response.headers["X-Credits-Total"] = str(request.state.credits_total)
        response.headers["X-Credits-Cost"] = str(request.state.credits_cost)
    return response
```

**Stripe initialization in lifespan** (`src/api/main.py`):

In the `lifespan` function, after Supabase init and before yield, add:
```python
import stripe
settings = get_settings()  # already exists in lifespan
if settings.stripe_secret_key:
    stripe.api_key = settings.stripe_secret_key
    logger.info("stripe_initialized")
```

**Tier-aware rate limiting** (`src/api/main.py`):

Replace the static `limiter = Limiter(key_func=_rate_limit_key, headers_enabled=True)` with a dynamic approach. Update `_rate_limit_key` to return the API key as before. Then on each data route, use SlowAPI's `@limiter.limit()` decorator with a dynamic limit function that reads the tier from the key record returned by `require_credits`.

The simplest approach: define tier rate limits as a constant dict in `deps.py`:
```python
TIER_RATE_LIMITS = {
    "free": "30/minute",
    "payg": "60/minute",
    "project": "120/minute",
}
```

Then in each data route, use `@limiter.limit(dynamic_limit_key)` where `dynamic_limit_key` is a callable that reads the tier from `request.state`. Alternatively, keep the existing static default (100/minute) and add a comment noting this should be refined once billing middleware is integrated -- this is acceptable since SlowAPI dynamic limits require the tier to be known before the route handler runs, which is complex with dependency injection.

**Pragmatic approach:** Set the default rate limit to the lowest tier (30/minute) in the limiter configuration. After `require_credits` runs, it stores the tier on `request.state`. For MVP, rate limits are enforced per-key at 30/minute for free, 60/minute for PAYG, 120/minute for Project. Use SlowAPI `@limiter.limit()` on each data route with a dynamic limit function:

```python
def _dynamic_rate_limit(request: Request) -> str:
    """Return tier-based rate limit string for the current request."""
    tier = getattr(request.state, "tier", "free")
    return TIER_RATE_LIMITS.get(tier, "30/minute")
```

BUT since SlowAPI evaluates the limit BEFORE the route handler (and thus before the dependency runs), the tier won't be on request.state yet. Therefore, the most practical approach for MVP:

Keep the existing static limiter as-is (100/minute). The credit system is the real enforcement mechanism -- when credits run out, the user is blocked regardless of rate. Tier-aware rate limits become a Phase 5 refinement or can be added via a custom middleware that runs after `require_credits`. Add a TODO comment in main.py.

Actually, there IS a clean approach: use SlowAPI's dynamic limit with a function that looks up the tier from the database based on the API key in the Authorization header. This adds one DB query per rate-limit check but keeps things correct:

```python
async def _tier_rate_limit(request: Request) -> str:
    # This runs synchronously for SlowAPI, so we can't do async DB lookups here.
    # Fallback to static limits; credit system enforces real limits.
    return "120/minute"  # Allow through, credits enforce actual limits
```

**Final decision:** Set the limiter default to `120/minute` (Project-tier max) as a backstop against abuse. The credit system (require_credits) is the real enforcement. Free users with 30 req/min and 1000 credits/month will exhaust credits long before rate limits matter. Add a comment explaining this design choice. This avoids the complexity of tier-aware SlowAPI while still preventing abuse.

Update `api_rate_limit_default` in config from 100 to 120 and update the limiter default string.

**Endpoint integration:**

Update each data route to use `require_credits` instead of bare `get_api_key`:

- `src/api/routes/orderbook.py`: Change `key: dict = Depends(get_api_key)` to `key: dict = Depends(require_credits(5))`
- `src/api/routes/deltas.py`: Change to `Depends(require_credits(2))`
- `src/api/routes/markets.py`: For GET /markets change to `Depends(require_credits(1))`, for GET /markets/{ticker} change to `Depends(require_credits(1))`

Update imports in each route file: replace `from src.api.deps import get_api_key` with `from src.api.deps import require_credits` (keep get_api_key import if still used elsewhere in the file).
  </action>
  <verify>
Run the full test suite:
```bash
uv run pytest tests/ -v
```

Start the server and test credit deduction manually:
```bash
uv run uvicorn src.api.main:app --port 8000 &
# Hit a market endpoint with a valid API key and check response headers
curl -s -D - -H "Authorization: Bearer kb-TESTKEY" http://localhost:8000/markets | head -20
# Should see X-Credits-Remaining, X-Credits-Used, X-Credits-Total, X-Credits-Cost headers
```

Verify imports:
```bash
uv run python -c "from src.api.deps import require_credits, CREDIT_COSTS; print(CREDIT_COSTS)"
```
  </verify>
  <done>
require_credits(cost) dependency factory chains after get_api_key, deducts credits atomically, logs per-key usage, reports PAYG overage to Stripe. Credit headers middleware injects X-Credits-Remaining/Used/Total/Cost on every response. All data endpoints (orderbook=5, deltas=2, markets=1) use require_credits. Stripe API key initialized in lifespan. Rate limiter set to 120/minute as abuse backstop (credit system is real enforcement).
  </done>
</task>

</tasks>

<verification>
1. `billing_accounts` table exists with correct schema (tier CHECK, credits columns, stripe mapping)
2. `api_key_usage` table exists with api_key_id FK and indexes
3. New user's first API request creates a free-tier billing_accounts row automatically
4. Orderbook request deducts 5 credits, deltas deducts 2, markets deducts 1
5. After 1,000 credits consumed (200 orderbook requests), next request returns 429 CreditsExhaustedError
6. Response headers include X-Credits-Remaining, X-Credits-Used, X-Credits-Total, X-Credits-Cost
7. api_key_usage table has one row per API request with endpoint and credits_charged
8. Monthly credit reset works: if billing_cycle_start is in previous month, credits_used resets to 0
9. stripe[async] installed and importable
10. `uv run pytest` passes
</verification>

<success_criteria>
- Every data endpoint deducts credits via require_credits dependency
- Free users get 1,000 credits/month, created lazily on first request
- Credits exhausted -> 429 with clear message
- PAYG users can exceed allocation (deduction succeeds, overage reported to Stripe)
- Per-key usage tracked in api_key_usage table
- Credit info in response headers on every request
</success_criteria>

<output>
After completion, create `.planning/phases/03-billing-monetization/03-01-SUMMARY.md`
</output>
