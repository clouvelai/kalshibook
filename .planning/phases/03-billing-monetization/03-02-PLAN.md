---
phase: 03-billing-monetization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/api/routes/billing.py
  - src/api/main.py
  - src/api/services/billing.py
  - static/llms.txt
  - static/llms-full.txt
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Users can upgrade to Project tier via Stripe Checkout and their credit allocation adjusts to 4,000/month"
    - "Users can manage their subscription via Stripe Customer Portal (cancel, update payment)"
    - "Stripe webhook events (subscription created/updated/deleted, payment failed) update local billing state"
    - "Users can enable PAYG via POST /billing/payg and overage credits are billed through Stripe"
    - "Users can check their billing status via GET /billing/status"
    - "AI agents can discover billing endpoints via updated llms.txt files"
  artifacts:
    - path: "src/api/routes/billing.py"
      provides: "Billing endpoints: checkout, portal, webhook, payg toggle, status"
      exports: ["router"]
    - path: "src/api/services/billing.py"
      provides: "Stripe integration helpers: sync_subscription_state, handle_subscription_canceled, handle_payment_failed, get_billing_status, toggle_payg"
      contains: "sync_subscription_state"
    - path: "static/llms-full.txt"
      provides: "Updated AI agent reference with billing endpoints and credit system docs"
      contains: "billing"
  key_links:
    - from: "src/api/routes/billing.py"
      to: "src/api/services/billing.py"
      via: "Routes call billing service functions"
      pattern: "sync_subscription_state|toggle_payg|get_billing_status"
    - from: "src/api/routes/billing.py"
      to: "stripe"
      via: "Checkout.create_async, Portal.create_async, Webhook.construct_event"
      pattern: "stripe\\."
    - from: "src/api/main.py"
      to: "src/api/routes/billing.py"
      via: "app.include_router(billing.router)"
      pattern: "include_router.*billing"
---

<objective>
Stripe-powered billing endpoints: Checkout for plan upgrades, Customer Portal for subscription management, webhook handler for lifecycle events, PAYG toggle, billing status endpoint, and updated AI discovery docs.

Purpose: Users can upgrade from free tier, manage subscriptions, enable pay-as-you-go billing, and AI agents can discover the full billing API.
Output: Complete billing API surface -- all Stripe integration endpoints working, webhook handler processing subscription events, llms.txt updated.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-billing-monetization/03-RESEARCH.md
@.planning/phases/03-billing-monetization/03-01-SUMMARY.md

@src/api/deps.py
@src/api/errors.py
@src/api/main.py
@src/api/models.py
@src/api/services/billing.py
@src/shared/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Billing routes and service layer for Stripe integration</name>
  <files>
    src/api/routes/billing.py
    src/api/services/billing.py
    src/api/main.py
  </files>
  <action>
**Create billing routes** (`src/api/routes/billing.py`):

Create a new router with `tags=["Billing"]`. Implement these endpoints:

**GET /billing/status** (authenticated via `get_authenticated_user`):
- Look up billing_accounts for user_id. If none exists, call ensure_billing_account to create free-tier row.
- Return BillingStatusResponse with tier, credits_total, credits_used, credits_remaining (computed), payg_enabled, billing_cycle_start, request_id.

**POST /billing/checkout** (authenticated via `get_authenticated_user`):
- Get or create billing account. If no stripe_customer_id exists, create a Stripe Customer via `stripe.Customer.create_async(email=user["email"], metadata={"kalshibook_user_id": str(user["user_id"])})` and save the customer ID to billing_accounts.
- Create a Stripe Checkout Session via `stripe.checkout.Session.create_async()` with:
  - `customer=stripe_customer_id`
  - `line_items=[{"price": settings.stripe_project_price_id, "quantity": 1}]`
  - `mode="subscription"`
  - `success_url=f"{settings.app_url}/billing?success=true"`
  - `cancel_url=f"{settings.app_url}/billing?canceled=true"`
- Return CheckoutResponse with checkout_url and request_id.

**POST /billing/portal** (authenticated via `get_authenticated_user`):
- Get billing account. If no stripe_customer_id, return 400 error: "No billing account found. Subscribe first."
- Create portal session via `stripe.billing_portal.Session.create_async(customer=stripe_customer_id, return_url=f"{settings.app_url}/billing")`.
- Return PortalResponse with portal_url and request_id.

**POST /billing/payg** (authenticated via `get_authenticated_user`, accepts PaygToggleRequest body):
- Get or create billing account via ensure_billing_account.
- If enabling PAYG: Require stripe_customer_id (user must have gone through checkout or have Stripe customer). If no Stripe customer, create one (same pattern as checkout).
- Update `payg_enabled` in billing_accounts. When enabling, also set tier to 'payg' if currently 'free'. When disabling, set tier back to 'free' if no active stripe_subscription_id.
- Return PaygToggleResponse with payg_enabled, message, request_id.

**POST /billing/webhook** (NO auth dependency -- uses Stripe signature verification):
- Read raw body via `await request.body()`. Get `stripe-signature` header.
- Verify signature via `stripe.Webhook.construct_event(payload, sig_header, settings.stripe_webhook_secret)`.
- Handle ValueError (invalid payload -> 400) and stripe.SignatureVerificationError (invalid signature -> 400).
- Route events:
  - `customer.subscription.created` / `customer.subscription.updated`: Call `sync_subscription_state(pool, event_data)`.
  - `customer.subscription.deleted`: Call `handle_subscription_canceled(pool, event_data)`.
  - `invoice.payment_failed`: Call `handle_payment_failed(pool, event_data)`.
  - Default: Log unhandled event type and return 200.
- Always return `{"received": True}`.

**Billing service additions** (`src/api/services/billing.py`):

Add these functions to the existing billing service file (do NOT overwrite existing functions from Plan 03-01):

- `get_billing_status(pool, user_id) -> dict | None`: SELECT from billing_accounts WHERE user_id. Return dict or None.
- `update_stripe_customer_id(pool, user_id, stripe_customer_id)`: UPDATE billing_accounts SET stripe_customer_id WHERE user_id.
- `toggle_payg(pool, user_id, enable: bool) -> dict`: UPDATE billing_accounts SET payg_enabled, tier (adjust based on enable/subscription state), RETURNING *.
- `sync_subscription_state(pool, subscription_data)`: Parse subscription object from Stripe webhook. Extract customer ID, look up billing_accounts by stripe_customer_id. Update tier to 'project', credits_total to 4000, stripe_subscription_id. Handle subscription status: 'active' -> project tier, 'past_due' -> keep project but log warning, 'canceled'/'unpaid' -> downgrade. Make handler idempotent.
- `handle_subscription_canceled(pool, subscription_data)`: Look up by stripe_customer_id. Set tier='free', credits_total=1000, stripe_subscription_id=NULL, payg_enabled=FALSE. Idempotent (handle missing record gracefully).
- `handle_payment_failed(pool, invoice_data)`: Log the failure with structured logging. Extract customer from invoice, look up billing account by customer. Log warning but do NOT immediately downgrade -- Stripe has its own retry schedule and will eventually send subscription.deleted if all retries fail.

**Register router** (`src/api/main.py`):

Add `from src.api.routes import billing` to imports. Add `app.include_router(billing.router)` after existing router registrations. Add "Billing" to openapi_tags list:
```python
{
    "name": "Billing",
    "description": (
        "Credit-based billing, Stripe subscription management, "
        "and usage tracking."
    ),
},
```
  </action>
  <verify>
Verify imports and app starts:
```bash
uv run python -c "from src.api.routes.billing import router; print(f'Routes: {len(router.routes)}')"
uv run uvicorn src.api.main:app --port 8000 &
sleep 2
# Check billing status endpoint exists (will 401 without auth but confirms route exists)
curl -s http://localhost:8000/billing/status | python3 -m json.tool
# Check OpenAPI spec includes billing endpoints
curl -s http://localhost:8000/openapi.json | python3 -c "import sys,json; spec=json.load(sys.stdin); print([p for p in spec['paths'] if 'billing' in p])"
kill %1
```

Run test suite:
```bash
uv run pytest tests/ -v
```
  </verify>
  <done>
All five billing endpoints created and registered: GET /billing/status, POST /billing/checkout, POST /billing/portal, POST /billing/payg, POST /billing/webhook. Billing service handles subscription lifecycle (created, updated, canceled, payment failed). Webhook uses raw body for signature verification. PAYG toggle creates Stripe customer if needed. All handlers are idempotent.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Stripe integration with test mode</name>
  <files>n/a (verification only)</files>
  <action>
Human verification of the complete billing system built in Plans 03-01 and 03-02 Task 1.

What was built: Credit metering on all data endpoints, Stripe Checkout for Project plan upgrades, Customer Portal for subscription management, PAYG toggle, webhook handler for subscription lifecycle, and billing status endpoint.

Prerequisites: Ensure Stripe test-mode API keys are in `.env` (STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, STRIPE_PROJECT_PRICE_ID, STRIPE_METER_EVENT_NAME). Create the required Stripe test-mode products/prices/meter if not already done.

Verification steps:

1. **Credit deduction test:**
   - Sign up, get API key
   - Call `GET /markets` with the API key
   - Check response headers: X-Credits-Remaining should be 999, X-Credits-Cost should be 1
   - Call `POST /orderbook` -- X-Credits-Remaining should decrease by 5

2. **Credit exhaustion test:**
   - Use test account with credits near 0 (or manually set credits_used = 999 in DB)
   - Call `POST /orderbook` (costs 5) -- should get 429 with "credits_exhausted" error

3. **Billing status:**
   - Call `GET /billing/status` with Supabase JWT -- should return tier, credits, payg_enabled

4. **Stripe Checkout:**
   - Call `POST /billing/checkout` with Supabase JWT
   - Open the returned checkout_url in browser
   - Verify it shows Stripe-hosted checkout page for $30/month Project plan
   - (Optionally complete with test card 4242424242424242)

5. **Webhook processing:**
   - Run `stripe listen --forward-to localhost:8000/billing/webhook` in a terminal
   - Complete a test checkout
   - Verify webhook events are received and billing_accounts is updated (tier='project', credits_total=4000)

6. **PAYG toggle:**
   - Call `POST /billing/payg` with `{"enable": true}` -- should enable PAYG
   - Verify billing_accounts.payg_enabled is TRUE
  </action>
  <verify>User performs the above steps and confirms all work correctly.</verify>
  <done>Type "approved" or describe issues to fix.</done>
</task>

<task type="auto">
  <name>Task 3: Update llms.txt AI discovery files with billing documentation</name>
  <files>
    static/llms.txt
    static/llms-full.txt
  </files>
  <action>
**Update `static/llms.txt`** (brief discovery file):

Add a "Billing" section to the existing llms.txt file. Keep it brief (this is the quick reference). Add after the existing endpoint listings:

```
## Billing

Credit-based API pricing. Each request costs credits (markets=1, deltas=2, orderbook=5).
Free tier: 1,000 credits/month (no card required).
Pay-As-You-Go: $0.008/credit overage billing.
Project: $30/month for 4,000 credits + higher rate limits.

Credit info returned in response headers: X-Credits-Remaining, X-Credits-Used, X-Credits-Total, X-Credits-Cost.
429 when credits exhausted.

Billing endpoints require Supabase JWT (from POST /auth/login), not API key.
- GET /billing/status - Current tier, credits, PAYG status
- POST /billing/checkout - Get Stripe Checkout URL for Project plan
- POST /billing/portal - Get Stripe Customer Portal URL
- POST /billing/payg - Enable/disable pay-as-you-go billing
```

**Update `static/llms-full.txt`** (comprehensive reference):

Add a detailed "Billing & Credits" section to the existing llms-full.txt. This should cover:

1. **Credit system overview**: How credits work, costs per endpoint, monthly reset, no rollover.
2. **Tier comparison table**: Free (1,000 credits, 30 req/min), PAYG (1,000 + overage at $0.008/credit, 60 req/min), Project ($30/mo, 4,000 credits, 120 req/min).
3. **Response headers**: X-Credits-Remaining, X-Credits-Used, X-Credits-Total, X-Credits-Cost -- present on every data endpoint response.
4. **Credit exhaustion**: 429 response with `credits_exhausted` error code. Options: wait for monthly reset, enable PAYG, upgrade to Project.
5. **Billing endpoints**: Full request/response examples for each billing endpoint (status, checkout, portal, payg). Note that billing endpoints use Supabase JWT auth (from /auth/login), NOT API key auth.
6. **Upgrade flow for AI agents**: Step-by-step: check status -> if credits low, present checkout URL to human user -> human completes Stripe Checkout -> credits increase automatically via webhook.
7. **Error codes**: credits_exhausted (429), no_billing_account (400), invalid_payload (400), invalid_signature (400).

Follow the existing style and structure of llms-full.txt. Keep the tone technical and agent-friendly.
  </action>
  <verify>
Check files exist and contain billing content:
```bash
grep -c "billing" static/llms.txt
grep -c "billing" static/llms-full.txt
grep "credits_exhausted" static/llms-full.txt
```

Verify llms.txt endpoints are served:
```bash
uv run uvicorn src.api.main:app --port 8000 &
sleep 2
curl -s http://localhost:8000/llms.txt | grep -i billing
curl -s http://localhost:8000/llms-full.txt | grep -i "X-Credits"
kill %1
```
  </verify>
  <done>
llms.txt updated with billing section (credit costs, tiers, billing endpoints). llms-full.txt updated with comprehensive billing documentation including credit system overview, tier comparison, response headers, exhaustion behavior, endpoint examples, agent upgrade flow, and error codes.
  </done>
</task>

</tasks>

<verification>
1. `POST /billing/checkout` returns a valid Stripe Checkout URL for the Project plan
2. `POST /billing/portal` returns a Stripe Customer Portal URL for subscription management
3. `POST /billing/webhook` correctly verifies Stripe signatures and processes subscription events
4. `POST /billing/payg` toggles PAYG billing and updates the billing account tier
5. `GET /billing/status` returns current tier, credit usage, and PAYG status
6. Completing a Stripe Checkout -> webhook fires -> billing_accounts updated to project tier with 4,000 credits
7. Canceling subscription via portal -> webhook fires -> billing_accounts downgraded to free tier with 1,000 credits
8. llms.txt includes billing endpoints and credit information
9. llms-full.txt includes comprehensive billing API documentation
10. `uv run pytest` passes
</verification>

<success_criteria>
- Users can upgrade to Project tier via Stripe Checkout and get 4,000 credits/month
- Users can manage subscriptions via Stripe Customer Portal
- Webhook handler processes subscription lifecycle events correctly
- Users can enable/disable PAYG billing
- Users can check their billing status
- AI agents can discover billing API via updated llms.txt files
</success_criteria>

<output>
After completion, create `.planning/phases/03-billing-monetization/03-02-SUMMARY.md`
</output>
