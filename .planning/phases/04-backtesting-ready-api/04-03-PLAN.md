---
phase: 04-backtesting-ready-api
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/api/routes/trades.py
  - src/api/routes/settlements.py
  - src/api/main.py
autonomous: true

must_haves:
  truths:
    - "POST /trades returns paginated trade history with cursor-based pagination for a market and time range"
    - "GET /settlements lists all settlement records"
    - "GET /settlements/{ticker} returns settlement data for a specific market"
    - "All endpoints use require_credits dependency for credit gating"
    - "All endpoints return standard response envelope with request_id and response_time"
  artifacts:
    - path: "src/api/routes/trades.py"
      provides: "POST /trades endpoint with cursor-based pagination"
      contains: "require_credits"
    - path: "src/api/routes/settlements.py"
      provides: "GET /settlements and GET /settlements/{ticker} endpoints"
      contains: "require_credits"
    - path: "src/api/main.py"
      provides: "Router registration for trades and settlements"
      contains: "trades"
  key_links:
    - from: "src/api/routes/trades.py"
      to: "src/api/deps.py"
      via: "require_credits(2) dependency"
      pattern: "require_credits"
    - from: "src/api/routes/settlements.py"
      to: "src/api/deps.py"
      via: "require_credits(1) dependency"
      pattern: "require_credits"
    - from: "src/api/main.py"
      to: "src/api/routes/trades.py"
      via: "app.include_router(trades.router)"
      pattern: "include_router"
---

<objective>
Create API endpoints for querying trade history and settlement data.

Purpose: Backtesters need access to real trade execution data for strategy validation and settlement/resolution data for P&L calculation. These are the two most fundamental data endpoints for backtesting beyond orderbook data.

Output: Two new route files (trades.py, settlements.py) registered in the API application.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-backtesting-ready-api/04-01-SUMMARY.md
@src/api/routes/deltas.py
@src/api/routes/markets.py
@src/api/deps.py
@src/api/models.py
@src/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trades and settlements route files</name>
  <files>
    src/api/routes/trades.py
    src/api/routes/settlements.py
  </files>
  <action>
**src/api/routes/trades.py** -- NEW FILE. Follow `deltas.py` exactly as the pattern:
- `router = APIRouter(tags=["Trades"])`
- Copy `_decode_cursor` and `_encode_cursor` helper functions from `deltas.py` (exact same logic -- base64-encoded orjson with ts/id composite cursor). Import base64, orjson, time, datetime, asyncpg, FastAPI deps.
- `POST /trades` endpoint:
  - Signature: `async def get_trades(request: Request, body: TradesRequest, key: dict = Depends(require_credits(2)), pool: asyncpg.Pool = Depends(get_db_pool))`
  - Credit cost: 2 (same as deltas -- paginated raw data query)
  - Query: SELECT from `trades` table with `market_ticker = $1 AND ts >= $2 AND ts < $3` filtering, cursor-based pagination using `(ts, id) > ($cursor_ts, $cursor_id)`, `ORDER BY ts ASC, id ASC`, `LIMIT $4` (fetch limit+1 for has_more detection)
  - Exact same pagination logic as deltas.py: fetch limit+1, check has_more, slice to limit, encode next_cursor from last row
  - Map rows to `TradeRecord` model (trade_id, market_ticker, yes_price, no_price, count, taker_side, ts as ISO 8601)
  - Return `TradesResponse` with data, next_cursor, has_more, request_id, response_time

**src/api/routes/settlements.py** -- NEW FILE. Follow `markets.py` as the pattern:
- `router = APIRouter(tags=["Settlements"])`
- `GET /settlements` endpoint:
  - Signature: `async def list_settlements(request: Request, key: dict = Depends(require_credits(1)), pool: asyncpg.Pool = Depends(get_db_pool))`
  - Credit cost: 1 (list query)
  - Query: `SELECT market_ticker, event_ticker, result, settlement_value, determined_at, settled_at FROM settlements ORDER BY determined_at DESC NULLS LAST`
  - Map rows to `SettlementRecord` model (ISO 8601 for timestamps)
  - Return `SettlementsResponse`
  - Optional query params: `event_ticker: str | None = None` to filter by event, `result: str | None = None` to filter by outcome
- `GET /settlements/{ticker}` endpoint:
  - Signature: `async def get_settlement(request: Request, ticker: str, key: dict = Depends(require_credits(1)), pool: asyncpg.Pool = Depends(get_db_pool))`
  - Credit cost: 1 (single-row lookup)
  - Query: `SELECT ... FROM settlements WHERE market_ticker = $1`
  - If no row found, raise a 404 error (create SettlementNotFoundError in errors.py or reuse NotFoundError pattern with custom message)
  - Return `SettlementResponse`

For the 404 error, add to `src/api/errors.py`:
```python
class SettlementNotFoundError(KalshiBookError):
    def __init__(self, ticker: str):
        super().__init__(
            code="settlement_not_found",
            message=f"No settlement data found for market '{ticker}'.",
            status=404,
        )
```
  </action>
  <verify>
1. `python -c "from src.api.routes.trades import router; from src.api.routes.settlements import router; print('OK')"` -- imports work
2. Start API server briefly: `uv run uvicorn src.api.main:app --host 0.0.0.0 --port 8000 &` then:
   - `curl -s http://localhost:8000/openapi.json | python -m json.tool | grep -c trades` -- trades endpoint appears in OpenAPI spec
   - `curl -s http://localhost:8000/openapi.json | python -m json.tool | grep -c settlements` -- settlements endpoint appears
  </verify>
  <done>POST /trades endpoint with cursor-based pagination exists, GET /settlements and GET /settlements/{ticker} exist, all with require_credits gating and standard response envelope.</done>
</task>

<task type="auto">
  <name>Task 2: Register new routers and add OpenAPI tags</name>
  <files>src/api/main.py</files>
  <action>
Update `src/api/main.py`:

1. Add imports: `from src.api.routes import trades, settlements`
2. Add OpenAPI tags to the `openapi_tags` list:
```python
{
    "name": "Trades",
    "description": "Query public trade execution history with market and time range filtering.",
},
{
    "name": "Settlements",
    "description": "Look up market resolution/settlement outcomes.",
},
```
3. Register routers after existing ones:
```python
app.include_router(trades.router)
app.include_router(settlements.router)
```

Keep the existing router registrations unchanged. Add new ones at the end of the router registration block.
  </action>
  <verify>
Start API: `uv run uvicorn src.api.main:app --host 0.0.0.0 --port 8000 &` and check:
- `curl -s http://localhost:8000/openapi.json | python -c "import sys,json; d=json.load(sys.stdin); print([t['name'] for t in d['tags']])"` shows Trades and Settlements tags
- `curl -s http://localhost:8000/docs` returns 200
  </verify>
  <done>Trades and settlements routers are registered in the FastAPI app with proper OpenAPI tags, and all endpoints appear in the auto-generated docs.</done>
</task>

</tasks>

<verification>
1. POST /trades accepts market_ticker, start_time, end_time, cursor, limit
2. Trades endpoint uses cursor-based pagination identical to deltas.py pattern
3. GET /settlements returns list of settlement records
4. GET /settlements/{ticker} returns single settlement or 404
5. All endpoints gated by require_credits with appropriate costs (trades=2, settlements=1)
6. All endpoints return request_id and response_time
7. OpenAPI spec includes new endpoints and tags
</verification>

<success_criteria>
- Trades and settlements endpoints appear in /openapi.json
- Trades uses POST with body-based filtering (same as deltas)
- Settlements uses GET with path/query params
- Credit costs: trades=2, settlements=1
- 404 error for missing settlement is clean JSON
- Existing endpoints unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/04-backtesting-ready-api/04-03-SUMMARY.md`
</output>
