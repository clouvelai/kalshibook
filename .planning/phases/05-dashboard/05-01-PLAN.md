---
phase: 05-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260217000001_add_key_type.sql
  - src/api/routes/keys.py
  - src/api/routes/auth.py
  - src/api/services/auth.py
  - src/api/models.py
  - .env.example
autonomous: true

must_haves:
  truths:
    - "api_keys table has a key_type column with CHECK constraint for 'dev' or 'prod', defaulting to 'dev'"
    - "GET /keys/usage returns per-key credit usage aggregated for the current billing cycle"
    - "POST /auth/signup auto-creates a billing account and a default 'default' API key for new users"
    - "POST /keys accepts an optional key_type field ('dev' or 'prod')"
  artifacts:
    - path: "supabase/migrations/20260217000001_add_key_type.sql"
      provides: "key_type column migration"
      contains: "key_type"
    - path: "src/api/routes/keys.py"
      provides: "Per-key usage endpoint"
      contains: "keys/usage"
    - path: "src/api/routes/auth.py"
      provides: "Auto-provisioning on signup"
      contains: "create_api_key"
    - path: "src/api/services/auth.py"
      provides: "key_type support in create_api_key"
      contains: "key_type"
  key_links:
    - from: "src/api/routes/auth.py"
      to: "src/api/services/auth.py"
      via: "create_api_key call after signup"
      pattern: "create_api_key.*default"
    - from: "src/api/routes/keys.py"
      to: "billing_accounts table"
      via: "SQL JOIN for billing_cycle_start scoping"
      pattern: "billing_cycle_start"
---

<objective>
Add backend support for dashboard features: key_type column on api_keys, per-key usage aggregation endpoint, and auto-provisioning of default key + billing account on signup.

Purpose: The dashboard needs key types for display, per-key usage for the keys table, and a default key present when new users first log in. These backend gaps must be filled before the frontend can be built.

Output: Database migration, updated auth/keys routes and services, updated models.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/api/routes/keys.py
@src/api/routes/auth.py
@src/api/services/auth.py
@src/api/services/billing.py
@src/api/models.py
@supabase/migrations/20260214000001_create_api_keys.sql
@supabase/migrations/20260215000001_create_billing_accounts.sql
@supabase/migrations/20260215000002_create_api_key_usage.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add key_type column and per-key usage endpoint</name>
  <files>
    supabase/migrations/20260217000001_add_key_type.sql
    src/api/routes/keys.py
    src/api/services/auth.py
    src/api/models.py
  </files>
  <action>
    1. Create migration `supabase/migrations/20260217000001_add_key_type.sql`:
       - `ALTER TABLE api_keys ADD COLUMN key_type TEXT NOT NULL DEFAULT 'dev' CHECK (key_type IN ('dev', 'prod'));`
       - Key types are cosmetic labels for now (no functional rate limit differences). Easy to extend later.

    2. Update `src/api/services/auth.py`:
       - Add `key_type: str = "dev"` parameter to `create_api_key()` function.
       - Include `key_type` in the INSERT statement and in the returned dict.
       - Update `list_api_keys()` to SELECT and return `key_type` in each row dict.

    3. Update `src/api/models.py`:
       - Add `key_type: str = Field(default="dev", description="Key type: 'dev' or 'prod'")` to `ApiKeyCreate` model.
       - Add `key_type` field to `ApiKeyInfo` (the list response model).
       - Add a `KeyUsageItem` model: `id: str, name: str, key_prefix: str, key_type: str, created_at: str, last_used_at: str | None, credits_used: int`.
       - Add a `KeysUsageResponse` model: `data: list[KeyUsageItem], request_id: str`.

    4. Add `GET /keys/usage` endpoint to `src/api/routes/keys.py`:
       - Requires `get_authenticated_user` + `get_db_pool` dependencies (same as other key endpoints).
       - SQL query: SELECT from api_keys LEFT JOIN api_key_usage, aggregating COALESCE(SUM(credits_charged), 0) as credits_used, scoped to current billing cycle via subquery on billing_accounts.billing_cycle_start for the user. Filter: ak.user_id = $1 AND ak.revoked_at IS NULL. GROUP BY ak.id, ak.name, ak.key_prefix, ak.key_type, ak.created_at, ak.last_used_at. ORDER BY ak.created_at DESC.
       - Return `KeysUsageResponse` with the aggregated data.

    5. Update existing `POST /keys` route in `src/api/routes/keys.py` to pass `body.key_type` to `create_api_key()`.
  </action>
  <verify>
    - `supabase db reset` succeeds (migration applies cleanly)
    - `uv run uvicorn src.api.main:app` starts without errors
    - `curl -H "Authorization: Bearer $JWT" http://localhost:8000/keys/usage` returns JSON with `data` array and `request_id`
  </verify>
  <done>
    - api_keys table has key_type column with 'dev'/'prod' CHECK constraint defaulting to 'dev'
    - GET /keys/usage returns per-key credit usage for the current billing cycle
    - POST /keys accepts optional key_type parameter
    - GET /keys returns key_type in each key object
  </done>
</task>

<task type="auto">
  <name>Task 2: Auto-provision default key and billing account on signup</name>
  <files>
    src/api/routes/auth.py
    .env.example
  </files>
  <action>
    1. Update `src/api/routes/auth.py` `signup()` endpoint:
       - After successful `supabase.auth_sign_up()`, auto-provision the new user:
         a. Import `ensure_billing_account` from `src.api.services.billing` and `create_api_key` from `src.api.services.auth`.
         b. Import `get_db_pool` from `src.api.deps` and add `pool: asyncpg.Pool = Depends(get_db_pool)` to the signup function signature.
         c. After getting the user_id from signup result, call `await ensure_billing_account(pool, user_id)` to create the billing account (free tier, 1000 credits).
         d. Call `await create_api_key(pool, user_id, name="default", key_type="dev")` to create the default API key.
         e. Wrap provisioning in try/except so signup still succeeds if provisioning fails (log warning but don't block signup). The lazy init pattern in the dashboard will handle missing keys for Google OAuth users.

    2. Add a comment noting that Google OAuth users won't go through this endpoint -- the dashboard uses a lazy init pattern (check keys on first load, create default if none exist) to handle OAuth signup.

    3. Update `.env.example` to add placeholders for dashboard env vars that will be needed:
       - `# Google OAuth (for dashboard login)` section
       - `GOOGLE_OAUTH_CLIENT_ID=your-google-oauth-client-id`
       - `GOOGLE_OAUTH_CLIENT_SECRET=your-google-oauth-client-secret`
  </action>
  <verify>
    - `uv run uvicorn src.api.main:app` starts without errors
    - Manual test: POST /auth/signup with a new email creates user AND creates a billing account + default API key (visible via GET /keys with the returned JWT)
  </verify>
  <done>
    - POST /auth/signup creates billing account + default "default" dev key for new users
    - Provisioning failure does not block signup (graceful degradation)
    - .env.example includes Google OAuth placeholders
  </done>
</task>

</tasks>

<verification>
- All migrations apply cleanly on `supabase db reset`
- FastAPI app starts without import errors
- GET /keys/usage returns per-key usage data
- POST /auth/signup provisions default key + billing account
- POST /keys accepts key_type parameter
- GET /keys includes key_type in response
</verification>

<success_criteria>
Backend is ready for the dashboard frontend: key types are stored, per-key usage is queryable, and new users get a default key on signup.
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard/05-01-SUMMARY.md`
</output>
