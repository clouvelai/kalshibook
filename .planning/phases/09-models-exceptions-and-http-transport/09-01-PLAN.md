---
phase: 09-models-exceptions-and-http-transport
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sdk/src/kalshibook/exceptions.py
  - sdk/src/kalshibook/_parsing.py
autonomous: true

must_haves:
  truths:
    - "Users can catch KalshiBookError to handle all SDK errors generically"
    - "Users can catch AuthenticationError, RateLimitError, CreditsExhaustedError, MarketNotFoundError individually"
    - "Every SDK exception carries status_code, response_body, and human-readable message"
    - "CreditsExhaustedError is a distinct class (not grouped under a generic PaymentError)"
    - "Datetime strings with Z suffix parse correctly on Python 3.10+"
  artifacts:
    - path: "sdk/src/kalshibook/exceptions.py"
      provides: "Complete exception hierarchy with KalshiBookError base and 5 specific subclasses"
      contains: "class KalshiBookError"
    - path: "sdk/src/kalshibook/_parsing.py"
      provides: "parse_datetime helper for cross-version ISO 8601 parsing"
      contains: "def parse_datetime"
  key_links:
    - from: "sdk/src/kalshibook/exceptions.py"
      to: "API error codes"
      via: "status_code and response_body attributes matching API error envelope"
      pattern: "status_code.*response_body"
---

<objective>
Create the SDK exception hierarchy and datetime parsing utility -- the foundational types that all other SDK modules depend on.

Purpose: Exceptions are imported by _http.py (error mapping), client.py (construction validation), and user code (catch blocks). The parsing helper is imported by models.py (from_dict factories). These must exist first.

Output: Two production-ready modules with no external dependencies beyond stdlib.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-models-exceptions-and-http-transport/09-RESEARCH.md
@.planning/phases/08-sdk-scaffolding/08-01-SUMMARY.md
@sdk/src/kalshibook/exceptions.py
@sdk/src/kalshibook/__init__.py
@src/api/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SDK exception hierarchy</name>
  <files>sdk/src/kalshibook/exceptions.py</files>
  <action>
Replace the empty stub with the complete exception hierarchy. All exceptions inherit from `KalshiBookError`.

`KalshiBookError(Exception)` base class:
- Constructor: `__init__(self, message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)`
- Stores `self.message`, `self.status_code`, `self.response_body` (default empty dict if None)
- Calls `super().__init__(message)`
- Include `from __future__ import annotations` and `from typing import Any`

Subclasses (each inherits from KalshiBookError, no extra logic -- just docstrings):
- `AuthenticationError` -- "API key is missing, malformed, or invalid."
- `RateLimitError` -- "Request was rate-limited (HTTP 429, code=rate_limit_exceeded). The SDK auto-retries these transparently. If you see this exception, all retry attempts were exhausted."
- `CreditsExhaustedError` -- "Monthly credit limit reached (HTTP 429, code=credits_exhausted). Not retryable. Enable Pay-As-You-Go or upgrade plan."
- `MarketNotFoundError` -- "The requested market, event, or settlement was not found (HTTP 404)."
- `ValidationError` -- "Request validation failed (HTTP 422)."

Note: The SDK's exception classes are SEPARATE from the server's `src/api/errors.py`. They share the same conceptual names but the SDK versions carry `status_code` and `response_body` attributes (not `code` and `status` like the server). Do NOT import from the server.
  </action>
  <verify>
Run: `cd /Users/samuelclark/Desktop/kalshibook && python -c "from kalshibook.exceptions import KalshiBookError, AuthenticationError, RateLimitError, CreditsExhaustedError, MarketNotFoundError, ValidationError; e = AuthenticationError('bad key', status_code=401, response_body={'error': {'code': 'invalid_api_key'}}); assert e.status_code == 401; assert e.response_body == {'error': {'code': 'invalid_api_key'}}; assert isinstance(e, KalshiBookError); print('OK')"`
  </verify>
  <done>All 5 exception subclasses importable, inherit from KalshiBookError, carry status_code/response_body/message attributes</done>
</task>

<task type="auto">
  <name>Task 2: Implement datetime parsing utility</name>
  <files>sdk/src/kalshibook/_parsing.py</files>
  <action>
Create `_parsing.py` with the `parse_datetime` helper function. This handles the Python 3.10 incompatibility where `datetime.fromisoformat()` rejects the `Z` suffix (3.11+ accepts it).

Contents:
```python
from __future__ import annotations

from datetime import datetime, timezone


def parse_datetime(value: str | None) -> datetime | None:
    """Parse an ISO 8601 datetime string to a timezone-aware datetime.

    Handles the 'Z' suffix that datetime.fromisoformat() rejects on Python 3.10.
    Returns None if the input is None or empty string.
    """
    if not value:
        return None
    # Python 3.10 fromisoformat doesn't accept 'Z', 3.11+ does.
    # Normalize to +00:00 for cross-version safety.
    normalized = value.replace("Z", "+00:00") if value.endswith("Z") else value
    dt = datetime.fromisoformat(normalized)
    # Ensure timezone-aware (server should always send tz-aware, but be defensive)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt
```

This is the ONLY place datetime parsing logic lives. All `from_dict()` methods in models.py will import and call `parse_datetime()`.
  </action>
  <verify>
Run: `cd /Users/samuelclark/Desktop/kalshibook && python -c "from kalshibook._parsing import parse_datetime; from datetime import timezone; dt1 = parse_datetime('2026-02-17T12:00:00Z'); assert dt1.tzinfo is not None; dt2 = parse_datetime('2026-02-17T12:00:00+00:00'); assert dt2 == dt1; assert parse_datetime(None) is None; assert parse_datetime('') is None; print('OK')"`
  </verify>
  <done>parse_datetime handles Z suffix, +00:00 suffix, None input, and empty string. All returned datetimes are timezone-aware.</done>
</task>

</tasks>

<verification>
1. `python -c "from kalshibook.exceptions import *"` -- all exception classes importable
2. `python -c "from kalshibook._parsing import parse_datetime"` -- parsing helper importable
3. `isinstance(AuthenticationError('x'), KalshiBookError)` returns True for all subclasses
4. `parse_datetime('2026-02-17T12:00:00Z')` succeeds on Python 3.10+
5. Exception instances carry `.status_code`, `.response_body`, `.message` attributes
</verification>

<success_criteria>
- exceptions.py contains KalshiBookError base + 5 subclasses with status_code/response_body/message
- _parsing.py contains parse_datetime handling Z suffix and None input
- All imports succeed without errors
- No dependencies beyond stdlib (typing, datetime)
</success_criteria>

<output>
After completion, create `.planning/phases/09-models-exceptions-and-http-transport/09-01-SUMMARY.md`
</output>
