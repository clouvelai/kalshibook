---
phase: 09-models-exceptions-and-http-transport
plan: 03
type: execute
wave: 3
depends_on: ["09-01", "09-02"]
files_modified:
  - sdk/src/kalshibook/_http.py
  - sdk/src/kalshibook/client.py
  - sdk/src/kalshibook/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can construct KalshiBook('kb-...') and KalshiBook.from_env() without errors"
    - "Passing an invalid key format raises AuthenticationError at construction time"
    - "KalshiBook(api_key=None) reads KALSHIBOOK_API_KEY from environment automatically"
    - "The client works in both sync=True mode and async mode (sync=False)"
    - "429 rate_limit_exceeded responses are retried transparently (3 attempts, exponential backoff)"
    - "429 credits_exhausted responses are NOT retried -- CreditsExhaustedError raised immediately"
    - "API errors map to specific exception types that users can catch individually"
    - "Client supports context manager protocol (with/async with)"
  artifacts:
    - path: "sdk/src/kalshibook/_http.py"
      provides: "Dual-mode HTTP transport with auth injection, retry, and error mapping"
      contains: "class HttpTransport"
    - path: "sdk/src/kalshibook/client.py"
      provides: "KalshiBook client class with constructor, from_env, close, context managers"
      contains: "class KalshiBook"
    - path: "sdk/src/kalshibook/__init__.py"
      provides: "Re-exports of KalshiBook, exceptions, and __version__"
      contains: "AuthenticationError"
  key_links:
    - from: "sdk/src/kalshibook/_http.py"
      to: "sdk/src/kalshibook/exceptions.py"
      via: "error code to exception class mapping"
      pattern: "_ERROR_MAP.*AuthenticationError"
    - from: "sdk/src/kalshibook/client.py"
      to: "sdk/src/kalshibook/_http.py"
      via: "self._transport = HttpTransport(...)"
      pattern: "HttpTransport"
    - from: "sdk/src/kalshibook/client.py"
      to: "sdk/src/kalshibook/exceptions.py"
      via: "raises AuthenticationError on invalid key format"
      pattern: "raise AuthenticationError"
    - from: "sdk/src/kalshibook/__init__.py"
      to: "sdk/src/kalshibook/exceptions.py"
      via: "re-exports all exception classes"
      pattern: "from kalshibook.exceptions import"
---

<objective>
Build the HTTP transport layer with dual-mode (sync/async) support, auth injection, retry with backoff, and error mapping -- then wire it into the KalshiBook client constructor with env var fallback, key validation, and context manager support.

Purpose: This completes Phase 9. After this plan, users can construct a client, and the transport is ready for Phase 10 to add endpoint methods on top.

Output: Working `_http.py` transport, fully implemented `client.py`, and updated `__init__.py` re-exports.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-models-exceptions-and-http-transport/09-RESEARCH.md
@sdk/src/kalshibook/_http.py
@sdk/src/kalshibook/client.py
@sdk/src/kalshibook/__init__.py
@sdk/src/kalshibook/exceptions.py
@sdk/src/kalshibook/models.py
@src/api/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement dual-mode HTTP transport with retry and error mapping</name>
  <files>sdk/src/kalshibook/_http.py</files>
  <action>
Replace the empty stub with the full HttpTransport class. This is the core networking layer.

**Imports:**
- `from __future__ import annotations`
- `import asyncio`, `import random`, `import time`
- `from typing import Any`
- `import httpx`
- All exception classes from `kalshibook.exceptions`
- `__version__` from `kalshibook`

**Error code mapping dict** (`_ERROR_MAP`):
Maps API `error.code` strings to SDK exception classes:
- `"invalid_api_key"` -> `AuthenticationError`
- `"rate_limit_exceeded"` -> `RateLimitError`
- `"credits_exhausted"` -> `CreditsExhaustedError`
- `"market_not_found"` -> `MarketNotFoundError`
- `"event_not_found"` -> `MarketNotFoundError`
- `"settlement_not_found"` -> `MarketNotFoundError`
- `"no_data_available"` -> `MarketNotFoundError`
- `"validation_error"` -> `ValidationError`
- `"invalid_timestamp"` -> `ValidationError`

**`_retry_delay(attempt: int) -> float`** function:
- Exponential backoff with jitter: `base = min(2 ** attempt, 8)`, `jitter = random.uniform(0, 0.5)`
- Returns `base + jitter` (so ~1s, ~2s, ~4s for attempts 0, 1, 2)

**`_raise_for_status(response: httpx.Response) -> None`** function:
- If `response.is_success`: return (no error)
- Try to parse JSON body and extract `error.code` and `error.message`
- If JSON parsing fails: use `code="unknown_error"`, `message=f"HTTP {response.status_code}"`
- Look up exception class in `_ERROR_MAP`, default to `KalshiBookError`
- Raise the exception with `message=message`, `status_code=response.status_code`, `response_body=body`

**`HttpTransport` class:**

Constructor `__init__(self, *, api_key: str, base_url: str, sync: bool = True, timeout: float = 30.0, max_retries: int = 3)`:
- Store `_sync`, `_max_retries`
- Build headers dict: `Authorization: Bearer {api_key}`, `User-Agent: kalshibook-python/{__version__}`, `Accept: application/json`
- Build `client_kwargs = dict(base_url=base_url, headers=headers, timeout=httpx.Timeout(timeout))`
- If sync: `self._client = httpx.Client(**client_kwargs)`
- If not sync: `self._client = httpx.AsyncClient(**client_kwargs)`

**`request_sync(self, method: str, path: str, **kwargs) -> httpx.Response`**:
- Retry loop: `for attempt in range(self._max_retries):`
  - `response = self._client.request(method, path, **kwargs)` (type: ignore for mypy since _client could be async)
  - If `response.status_code == 429`:
    - Parse body to get `error.code`
    - If `error.code == "credits_exhausted"`: break (do NOT retry)
    - Otherwise (rate limit): check `Retry-After` header, else use `_retry_delay(attempt)`, then `time.sleep(delay)` and `continue`
  - Otherwise: break
- After loop: call `_raise_for_status(response)` to raise if still error
- Return `response`

**`async request_async(self, method: str, path: str, **kwargs) -> httpx.Response`**:
- Same logic as `request_sync` but uses `await self._client.request(...)` and `await asyncio.sleep(delay)` instead of `time.sleep(delay)`

**`close(self) -> None`**: calls `self._client.close()` (for sync client)
**`async aclose(self) -> None`**: calls `await self._client.aclose()` (for async client)

Important: Use `# type: ignore[union-attr]` on the `.request()` calls since mypy cannot narrow the union type of `_client`. This is acceptable -- the caller ensures the right method is used based on `_sync`.

Note on `__version__` import: To avoid circular imports (since `__init__.py` imports from `client.py` which imports from `_http.py`), use a lazy import or hardcode the version string. Simplest approach: define `_VERSION = "0.1.0"` locally in `_http.py` for now. Phase 12 (PyPI publishing) can refactor to a single source of truth.
  </action>
  <verify>
Run: `cd /Users/samuelclark/Desktop/kalshibook && python -c "
from kalshibook._http import HttpTransport, _raise_for_status, _retry_delay, _ERROR_MAP
from kalshibook.exceptions import AuthenticationError, MarketNotFoundError

# Verify error map has expected entries
assert _ERROR_MAP['invalid_api_key'] is AuthenticationError
assert _ERROR_MAP['market_not_found'] is MarketNotFoundError

# Verify retry delay is reasonable
d0 = _retry_delay(0)
assert 1.0 <= d0 <= 1.5
d1 = _retry_delay(1)
assert 2.0 <= d1 <= 2.5

# Verify transport can be constructed (sync mode)
t = HttpTransport(api_key='kb-test123', base_url='http://localhost:8000', sync=True)
assert t._sync is True
t.close()

print('OK')
"`
  </verify>
  <done>HttpTransport class creates sync or async httpx client, has request_sync/request_async with retry, error mapping from API codes to SDK exceptions, exponential backoff on rate limits, no retry on credits_exhausted</done>
</task>

<task type="auto">
  <name>Task 2: Implement KalshiBook client constructor and update __init__.py re-exports</name>
  <files>sdk/src/kalshibook/client.py, sdk/src/kalshibook/__init__.py</files>
  <action>
**client.py -- Replace the empty stub with the full KalshiBook class:**

Imports:
- `from __future__ import annotations`
- `import os`
- `from typing import Any`
- `from kalshibook._http import HttpTransport`
- `from kalshibook.exceptions import AuthenticationError`

**`KalshiBook` class:**

Constructor `__init__(self, api_key: str | None = None, *, base_url: str = "https://api.kalshibook.io", sync: bool = True, timeout: float = 30.0, max_retries: int = 3)`:
- API key as first **positional** arg per locked decision
- Resolve key: `resolved_key = api_key or os.environ.get("KALSHIBOOK_API_KEY", "")`
- If not resolved_key: raise `AuthenticationError(message="No API key provided. Pass api_key= or set KALSHIBOOK_API_KEY environment variable.", status_code=0, response_body={})`
- If not resolved_key.startswith("kb-"): raise `AuthenticationError(message=f"Invalid API key format. Keys must start with 'kb-', got '{resolved_key[:10]}...'", status_code=0, response_body={})`
- Create transport: `self._transport = HttpTransport(api_key=resolved_key, base_url=base_url, sync=sync, timeout=timeout, max_retries=max_retries)`
- Store: `self._sync = sync`

`@classmethod from_env(cls, **kwargs) -> KalshiBook`:
- Docstring: "Create client using KALSHIBOOK_API_KEY environment variable."
- Body: `return cls(api_key=None, **kwargs)`

Context manager support (per locked decision -- both sync and async):
- `def __enter__(self) -> KalshiBook: return self`
- `def __exit__(self, *args: Any) -> None: self.close()`
- `async def __aenter__(self) -> KalshiBook: return self`
- `async def __aexit__(self, *args: Any) -> None: await self.aclose()`

Cleanup methods:
- `def close(self) -> None:` calls `self._transport.close()`
- `async def aclose(self) -> None:` calls `await self._transport.aclose()`

Update the class docstring to reflect the actual API:
```
"""Client for the KalshiBook API.

Provides sync and async access to historical orderbook data,
trades, candles, events, and settlements for Kalshi prediction markets.

Usage::

    # Sync (default -- scripts and notebooks)
    client = KalshiBook("kb-your-api-key")

    # From environment variable
    client = KalshiBook.from_env()

    # Async
    client = KalshiBook("kb-your-api-key", sync=False)

    # Context manager
    with KalshiBook("kb-your-api-key") as client:
        ...

Parameters
----------
api_key : str, optional
    KalshiBook API key (must start with 'kb-'). If not provided,
    reads from KALSHIBOOK_API_KEY environment variable.
base_url : str, optional
    API base URL. Default: https://api.kalshibook.io
sync : bool, optional
    If True (default), use synchronous HTTP transport.
    Set to False for async usage in event loop contexts.
timeout : float, optional
    Request timeout in seconds. Default: 30.0
max_retries : int, optional
    Maximum retry attempts for rate-limited requests. Default: 3
"""
```

**__init__.py -- Update re-exports:**

Update to re-export exception classes alongside KalshiBook and __version__:

```python
"""KalshiBook Python SDK -- L2 orderbook data for Kalshi prediction markets."""

from __future__ import annotations

__version__ = "0.1.0"

from kalshibook.client import KalshiBook
from kalshibook.exceptions import (
    AuthenticationError,
    CreditsExhaustedError,
    KalshiBookError,
    MarketNotFoundError,
    RateLimitError,
    ValidationError,
)

__all__ = [
    "KalshiBook",
    "__version__",
    "KalshiBookError",
    "AuthenticationError",
    "RateLimitError",
    "CreditsExhaustedError",
    "MarketNotFoundError",
    "ValidationError",
]
```

This follows the Stripe SDK pattern -- users can import exceptions from the top-level package: `from kalshibook import KalshiBook, AuthenticationError`.
  </action>
  <verify>
Run: `cd /Users/samuelclark/Desktop/kalshibook && python -c "
import os
from kalshibook import KalshiBook, AuthenticationError, KalshiBookError, RateLimitError, CreditsExhaustedError, MarketNotFoundError, ValidationError, __version__

# Test 1: Valid key construction
client = KalshiBook('kb-test-key-123')
assert client._sync is True
client.close()

# Test 2: from_env with env var
os.environ['KALSHIBOOK_API_KEY'] = 'kb-env-key-456'
client2 = KalshiBook.from_env()
client2.close()
del os.environ['KALSHIBOOK_API_KEY']

# Test 3: Missing key raises AuthenticationError
try:
    KalshiBook()
    assert False, 'Should have raised'
except AuthenticationError as e:
    assert 'No API key' in e.message

# Test 4: Invalid key format raises AuthenticationError
try:
    KalshiBook('jwt-token-not-kb-key')
    assert False, 'Should have raised'
except AuthenticationError as e:
    assert 'kb-' in e.message

# Test 5: Context manager (sync)
with KalshiBook('kb-test-key') as client3:
    assert client3._sync is True

# Test 6: Async construction
client4 = KalshiBook('kb-test-key', sync=False)
assert client4._sync is False

# Test 7: Custom base_url
client5 = KalshiBook('kb-test', base_url='http://localhost:8000')
client5.close()

# Test 8: All exceptions importable from top-level
assert issubclass(AuthenticationError, KalshiBookError)
assert issubclass(RateLimitError, KalshiBookError)
assert issubclass(CreditsExhaustedError, KalshiBookError)
assert issubclass(MarketNotFoundError, KalshiBookError)
assert issubclass(ValidationError, KalshiBookError)

print('OK -- all Phase 9 success criteria verified')
" && python -c "
# Async context manager test
import asyncio
from kalshibook import KalshiBook

async def test():
    async with KalshiBook('kb-test-key', sync=False) as client:
        assert client._sync is False
    print('Async context manager OK')

asyncio.run(test())
"`
  </verify>
  <done>KalshiBook constructor validates API key format, reads from env var, creates transport. from_env() works. Both sync and async context managers work. All exceptions re-exported from __init__.py. All 5 Phase 9 success criteria met.</done>
</task>

</tasks>

<verification>
1. `KalshiBook("kb-test")` constructs without error (Success Criterion 1)
2. `KalshiBook.from_env()` reads KALSHIBOOK_API_KEY from env (Success Criterion 1)
3. `KalshiBook("jwt-bad")` raises AuthenticationError with clear message (Success Criterion 2)
4. Exception hierarchy: AuthenticationError, RateLimitError, CreditsExhaustedError, MarketNotFoundError all catchable individually and via KalshiBookError (Success Criterion 3)
5. ResponseMeta on response objects has credits_used and credits_remaining (Success Criterion 4 -- verified by construction, endpoint methods in Phase 10 will use this)
6. `KalshiBook("kb-test", sync=True)` and `KalshiBook("kb-test", sync=False)` both construct (Success Criterion 5)
7. `from kalshibook import KalshiBook, AuthenticationError, ...` -- top-level imports work
8. 429 retry logic: rate_limit_exceeded retried with backoff, credits_exhausted NOT retried
</verification>

<success_criteria>
- _http.py has HttpTransport with sync/async request methods, retry on rate limits, error code mapping
- client.py has KalshiBook class with positional api_key, env var fallback, key format validation, context managers
- __init__.py re-exports all exception classes alongside KalshiBook and __version__
- All 5 Phase 9 success criteria from ROADMAP.md are met
- Zero new runtime dependencies (only httpx, already declared)
</success_criteria>

<output>
After completion, create `.planning/phases/09-models-exceptions-and-http-transport/09-03-SUMMARY.md`
</output>
