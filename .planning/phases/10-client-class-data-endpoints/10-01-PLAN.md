---
phase: 10-client-class-data-endpoints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sdk/src/kalshibook/client.py
autonomous: true

must_haves:
  truths:
    - "client.get_orderbook(ticker, timestamp) dispatches POST /orderbook with JSON body and returns typed OrderbookResponse"
    - "client.list_markets() dispatches GET /markets and returns typed MarketsResponse with list of MarketSummary"
    - "client.get_market(ticker) dispatches GET /markets/{ticker} and returns typed MarketDetailResponse"
    - "client.get_candles(ticker, start_time=, end_time=, interval=) dispatches GET /candles/{ticker} with query params and returns CandlesResponse"
    - "client.list_events() dispatches GET /events with optional filters and returns EventsResponse"
    - "client.get_event(event_ticker) dispatches GET /events/{event_ticker} and returns EventDetailResponse"
    - "Every sync method has an async counterpart prefixed with 'a' (aget_orderbook, alist_markets, etc.)"
    - "Naive datetimes passed by users are defensively made UTC-aware before serialization"
  artifacts:
    - path: "sdk/src/kalshibook/client.py"
      provides: "All endpoint methods (sync and async) plus _request/_arequest/_parse_response helpers"
      contains: "def get_orderbook"
  key_links:
    - from: "sdk/src/kalshibook/client.py"
      to: "sdk/src/kalshibook/_http.py"
      via: "self._transport.request_sync / request_async"
      pattern: "self\\._transport\\.request_(sync|async)"
    - from: "sdk/src/kalshibook/client.py"
      to: "sdk/src/kalshibook/models.py"
      via: "ResponseMeta.from_headers and Model.from_dict"
      pattern: "ResponseMeta\\.from_headers|from_dict"
---

<objective>
Implement all 6 non-paginated endpoint methods (sync + async) on the KalshiBook client class, plus private helper methods for request dispatch and response parsing.

Purpose: Users can call typed methods like `client.get_orderbook(ticker, ts)` and receive structured dataclass responses instead of raw dicts.
Output: Fully wired `client.py` with 12 public methods (6 sync + 6 async) and 3 private helpers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-models-exceptions-and-http-transport/09-03-SUMMARY.md
@sdk/src/kalshibook/client.py
@sdk/src/kalshibook/_http.py
@sdk/src/kalshibook/models.py
@sdk/src/kalshibook/_parsing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add private helpers and all endpoint methods to KalshiBook client</name>
  <files>sdk/src/kalshibook/client.py</files>
  <action>
Add the following to the existing KalshiBook class in client.py, below the `aclose()` method:

**Imports to add at top of file:**
- `from datetime import datetime, timezone`
- `import httpx` (for type annotation on _request/_arequest return)
- `from kalshibook.models import (ResponseMeta, OrderbookResponse, MarketsResponse, MarketDetailResponse, CandlesResponse, EventsResponse, EventDetailResponse)`

**Private helpers (add between the cleanup section and the first endpoint method):**

1. `_ensure_tz(self, dt: datetime) -> datetime` -- if `dt.tzinfo is None`, return `dt.replace(tzinfo=timezone.utc)`, else return `dt` unchanged. This defensively handles naive datetimes from users (matching the pattern in `_parsing.py`).

2. `_request(self, method: str, path: str, **kwargs: Any) -> httpx.Response` -- delegates to `self._transport.request_sync(method, path, **kwargs)` and returns the response.

3. `async _arequest(self, method: str, path: str, **kwargs: Any) -> httpx.Response` -- delegates to `await self._transport.request_async(method, path, **kwargs)` and returns the response.

4. `_parse_response(self, resp: httpx.Response, model_cls: type) -> Any` -- calls `body = resp.json()`, `meta = ResponseMeta.from_headers(dict(resp.headers), body)`, and returns `model_cls.from_dict(body, meta)`.

**Endpoint methods (6 sync + 6 async, all below the helpers):**

For each endpoint, implement both sync and async versions following this pattern:

**(a) get_orderbook / aget_orderbook** -- `POST /orderbook`
- Args: `ticker: str, timestamp: datetime, *, depth: int | None = None`
- Build JSON body: `{"market_ticker": ticker, "timestamp": self._ensure_tz(timestamp).isoformat()}`, add `"depth": depth` if not None
- Sync: `resp = self._request("POST", "/orderbook", json=body)` then `return self._parse_response(resp, OrderbookResponse)`
- Async: same but `resp = await self._arequest(...)`
- Returns: `OrderbookResponse`
- Docstring: document ticker, timestamp (timezone-aware recommended), depth, returns, and common errors (MarketNotFoundError, ValidationError)

**(b) list_markets / alist_markets** -- `GET /markets`
- No args
- Sync: `resp = self._request("GET", "/markets")` then `return self._parse_response(resp, MarketsResponse)`
- Returns: `MarketsResponse`

**(c) get_market / aget_market** -- `GET /markets/{ticker}`
- Args: `ticker: str`
- Sync: `resp = self._request("GET", f"/markets/{ticker}")` then `return self._parse_response(resp, MarketDetailResponse)`
- Returns: `MarketDetailResponse`

**(d) get_candles / aget_candles** -- `GET /candles/{ticker}`
- Args: `ticker: str, *, start_time: datetime, end_time: datetime, interval: str = "1h"`
- Build params dict: `{"start_time": self._ensure_tz(start_time).isoformat(), "end_time": self._ensure_tz(end_time).isoformat(), "interval": interval}`
- Sync: `resp = self._request("GET", f"/candles/{ticker}", params=params)` then parse
- Returns: `CandlesResponse`
- Docstring: document valid intervals (1m, 1h, 1d) but do NOT validate client-side -- let server validate for forward-compatibility

**(e) list_events / alist_events** -- `GET /events`
- Args: `*, category: str | None = None, series_ticker: str | None = None, status: str | None = None`
- Build params dict only with non-None values. Pass `params=params or None` to avoid sending empty query string.
- Returns: `EventsResponse`

**(f) get_event / aget_event** -- `GET /events/{event_ticker}`
- Args: `event_ticker: str`
- Sync: `resp = self._request("GET", f"/events/{event_ticker}")` then parse
- Returns: `EventDetailResponse`

Each method should have a concise docstring with parameter descriptions and return type.
  </action>
  <verify>
Run `cd /Users/samuelclark/Desktop/kalshibook && uv run python -c "from kalshibook import KalshiBook; print([m for m in dir(KalshiBook) if not m.startswith('_') and m != 'from_env'])"` and confirm all 14 methods are listed (6 sync: get_orderbook, list_markets, get_market, get_candles, list_events, get_event; 6 async: aget_orderbook, alist_markets, aget_market, aget_candles, alist_events, aget_event; plus close, aclose).

Also run `cd /Users/samuelclark/Desktop/kalshibook && uv run python -c "import inspect; from kalshibook import KalshiBook; sig = inspect.signature(KalshiBook.get_orderbook); print(sig)"` to verify the method signature includes (self, ticker: str, timestamp: datetime, *, depth: int | None = None).
  </verify>
  <done>
All 12 public endpoint methods exist on KalshiBook class with correct signatures. Each sync method has a matching async (a-prefixed) counterpart. Private helpers _request, _arequest, _parse_response, and _ensure_tz are in place. File imports all necessary models. No raw dicts returned -- every method returns a typed dataclass response.
  </done>
</task>

</tasks>

<verification>
1. `from kalshibook import KalshiBook` succeeds
2. All 12 endpoint methods are listed in `dir(KalshiBook)` with correct names
3. Method signatures have correct parameter types (datetime, str, int | None)
4. Return type annotations reference response model classes (not dict or Any)
5. `_ensure_tz` handles naive datetimes by adding UTC
6. No `None` values leak into httpx params dicts
</verification>

<success_criteria>
- KalshiBook class has 12 new public methods (6 sync + 6 async) covering all Phase 10 requirements (DATA-01, DATA-04, DATA-05, DATA-06, DATA-08)
- Every method follows the pipeline: build params -> _request/_arequest -> _parse_response -> return typed model
- Naive datetimes are defensively made UTC-aware via _ensure_tz
- No client-side interval validation (server validates for forward-compatibility)
- Optional filter params (list_events) only included when not None
</success_criteria>

<output>
After completion, create `.planning/phases/10-client-class-data-endpoints/10-01-SUMMARY.md`
</output>
