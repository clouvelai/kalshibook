---
phase: 10-client-class-data-endpoints
plan: 02
type: tdd
wave: 2
depends_on: ["10-01"]
files_modified:
  - sdk/tests/test_endpoints.py
autonomous: true

must_haves:
  truths:
    - "Sync get_orderbook returns OrderbookResponse with correct fields when API returns valid JSON"
    - "Sync list_markets returns MarketsResponse with list of MarketSummary objects"
    - "Sync get_market returns MarketDetailResponse with nested MarketDetail"
    - "Sync get_candles returns CandlesResponse with CandleRecord list"
    - "Sync list_events returns EventsResponse with EventSummary list"
    - "Sync get_event returns EventDetailResponse with nested EventDetail and child markets"
    - "Async variants (aget_*) produce the same typed responses as sync counterparts"
    - "ResponseMeta credits_used and credits_remaining are correctly extracted from response headers"
    - "API error responses raise the correct typed SDK exception (MarketNotFoundError, ValidationError)"
  artifacts:
    - path: "sdk/tests/test_endpoints.py"
      provides: "Comprehensive endpoint method tests using pytest-httpx mocks"
      contains: "def test_get_orderbook"
  key_links:
    - from: "sdk/tests/test_endpoints.py"
      to: "sdk/src/kalshibook/client.py"
      via: "KalshiBook() method calls"
      pattern: "client\\.get_orderbook|client\\.list_markets|client\\.get_market"
    - from: "sdk/tests/test_endpoints.py"
      to: "sdk/src/kalshibook/models.py"
      via: "assert on response model attributes"
      pattern: "result\\.data\\.ticker|result\\.meta\\.credits"
---

<objective>
Write comprehensive tests for all 6 endpoint methods (sync and async) using pytest-httpx mocks, covering happy paths, ResponseMeta extraction, and error mapping.

Purpose: Verify that every endpoint method correctly dispatches HTTP requests, parses responses into typed models, and maps errors to SDK exceptions.
Output: `sdk/tests/test_endpoints.py` with full test coverage for all Phase 10 endpoint methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-client-class-data-endpoints/10-01-SUMMARY.md
@sdk/src/kalshibook/client.py
@sdk/src/kalshibook/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write sync endpoint tests with pytest-httpx mocks</name>
  <files>sdk/tests/test_endpoints.py</files>
  <action>
Create `sdk/tests/test_endpoints.py` with pytest-httpx based tests. Use the TDD RED-GREEN cycle: write tests first, verify they pass against the implementation from Plan 10-01.

**Test fixtures / constants (top of file):**
- Import: `pytest`, `from datetime import datetime, timezone`, `from kalshibook import KalshiBook`, all response model classes, all exception classes
- Define `BASE_URL = "https://api.kalshibook.io"` for URL matching
- Define `CREDIT_HEADERS = {"x-credits-cost": "1", "x-credits-remaining": "999"}` reusable header dict
- Define `CREDIT_HEADERS_5 = {"x-credits-cost": "5", "x-credits-remaining": "995"}` for orderbook (5 credits)

**Sync happy-path tests (one per endpoint):**

1. `test_get_orderbook(httpx_mock)` -- mock POST to `{BASE_URL}/orderbook`, respond with JSON matching OrderbookResponse shape (market_ticker, timestamp, snapshot_basis, deltas_applied, yes/no level arrays, request_id, response_time). Assert: `result.market_ticker == "KXBTC-TEST"`, `len(result.yes) == 2`, `result.meta.credits_used == 5`.

2. `test_list_markets(httpx_mock)` -- mock GET `{BASE_URL}/markets`, respond with `{"data": [{"ticker": "MKT-1", ...}], "request_id": "...", "response_time": 0.01}`. Assert: `len(result.data) == 1`, `result.data[0].ticker == "MKT-1"`.

3. `test_get_market(httpx_mock)` -- mock GET `{BASE_URL}/markets/KXBTC-TEST`, respond with `{"data": {...MarketDetail fields...}, ...}`. Assert: `result.data.ticker == "KXBTC-TEST"`, `result.data.snapshot_count == 100`.

4. `test_get_candles(httpx_mock)` -- mock GET `{BASE_URL}/candles/KXBTC-TEST*` (with query params), respond with candle data. Assert: `len(result.data) == 1`, `result.data[0].open == 55`, `result.data[0].market_ticker == "KXBTC-TEST"`.

5. `test_list_events(httpx_mock)` -- mock GET `{BASE_URL}/events`, respond with event list. Assert: `len(result.data) == 1`, `result.data[0].event_ticker == "KXBTC"`.

6. `test_get_event(httpx_mock)` -- mock GET `{BASE_URL}/events/KXBTC`, respond with event detail including nested markets list. Assert: `result.data.event_ticker == "KXBTC"`, `len(result.data.markets) == 2`.

**ResponseMeta test:**

7. `test_response_meta_extracted(httpx_mock)` -- mock any simple endpoint (e.g., list_markets), set credit headers. Assert: `result.meta.credits_used == 1`, `result.meta.credits_remaining == 999`, `result.meta.request_id == "req_test"`.

**Error mapping tests:**

8. `test_market_not_found_raises(httpx_mock)` -- mock GET `/markets/NONEXISTENT` with 404 response and `{"error": {"code": "market_not_found", "message": "..."}}`. Assert: `pytest.raises(MarketNotFoundError)`, check `exc.status_code == 404`.

9. `test_validation_error_raises(httpx_mock)` -- mock POST `/orderbook` with 422 response and `{"error": {"code": "validation_error", "message": "..."}}`. Assert: `pytest.raises(ValidationError)`.

**Naive datetime test:**

10. `test_naive_datetime_gets_utc(httpx_mock)` -- mock POST `/orderbook`, call `get_orderbook("T", datetime(2026, 1, 1, 12, 0))` (naive). Inspect the request body from `httpx_mock.get_request()` and verify the timestamp includes `+00:00` (UTC was added).

**Optional filter params test:**

11. `test_list_events_filters(httpx_mock)` -- mock GET `/events`, call `list_events(category="Crypto", status="active")`. Inspect request URL params from `httpx_mock.get_request()` and verify `category=Crypto` and `status=active` are present but `series_ticker` is NOT in the query string.

Each test creates `KalshiBook("kb-test-key")` (sync mode, default). All tests use `httpx_mock.add_response(url=..., json=..., headers=CREDIT_HEADERS)`.
  </action>
  <verify>Run `cd /Users/samuelclark/Desktop/kalshibook && uv run pytest sdk/tests/test_endpoints.py -v` and confirm all tests pass.</verify>
  <done>All sync endpoint tests pass. Every endpoint method is verified for: correct HTTP dispatch, response model parsing, ResponseMeta extraction, error mapping, naive datetime handling, and optional filter parameters.</done>
</task>

<task type="auto">
  <name>Task 2: Write async endpoint tests</name>
  <files>sdk/tests/test_endpoints.py</files>
  <action>
Add async test functions to the same `sdk/tests/test_endpoints.py` file, below the sync tests.

**Async tests (3 representative methods -- no need to test all 6 since the async dispatch path is identical across methods):**

1. `test_aget_orderbook(httpx_mock)` -- decorated with `@pytest.mark.asyncio`. Create `KalshiBook("kb-test-key", sync=False)`. Mock POST `/orderbook`. Call `result = await client.aget_orderbook(...)`. Assert same fields as sync test. Call `await client.aclose()` at end.

2. `test_aget_market(httpx_mock)` -- decorated with `@pytest.mark.asyncio`. Create async client, mock GET `/markets/KXBTC-TEST`. Assert `result.data.ticker == "KXBTC-TEST"`.

3. `test_alist_events(httpx_mock)` -- decorated with `@pytest.mark.asyncio`. Create async client, mock GET `/events`. Assert `len(result.data) >= 1`.

These 3 tests cover: POST body dispatch (orderbook), path param dispatch (market), and query param dispatch (events) -- the 3 distinct async code paths. If all 3 pass, the `_arequest` dispatch is verified for all endpoint shapes.
  </action>
  <verify>Run `cd /Users/samuelclark/Desktop/kalshibook && uv run pytest sdk/tests/test_endpoints.py -v` and confirm all tests (sync + async) pass.</verify>
  <done>All async endpoint tests pass. The _arequest dispatch path is verified for POST-with-body, GET-with-path-param, and GET-with-query-params patterns. Combined with sync tests, full endpoint coverage is achieved.</done>
</task>

</tasks>

<verification>
1. `uv run pytest sdk/tests/test_endpoints.py -v` -- all tests pass (expect ~14 tests)
2. Every endpoint method has at least one sync test
3. 3 representative async tests cover all dispatch patterns
4. Error mapping verified for 404 (MarketNotFoundError) and 422 (ValidationError)
5. ResponseMeta extraction tested with real credit headers
6. Naive datetime defensive UTC handling tested
7. Optional filter param inclusion/exclusion tested
</verification>

<success_criteria>
- All ~14 tests pass with zero failures
- Every Phase 10 requirement (DATA-01, DATA-04, DATA-05, DATA-06, DATA-08) has at least one corresponding test
- Tests use pytest-httpx mocks (no real network calls)
- Async tests properly use @pytest.mark.asyncio and await
- No flaky tests (deterministic mock responses)
</success_criteria>

<output>
After completion, create `.planning/phases/10-client-class-data-endpoints/10-02-SUMMARY.md`
</output>
