---
phase: 11-pagination-dataframe-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sdk/src/kalshibook/_pagination.py
  - sdk/src/kalshibook/models.py
  - sdk/src/kalshibook/__init__.py
autonomous: true

must_haves:
  truths:
    - "PageIterator supports sync iteration via `for item in iterator`"
    - "PageIterator supports async iteration via `async for item in iterator`"
    - "PageIterator.to_df() materialises all records (including already-iterated) into a pandas DataFrame"
    - "to_df() raises ImportError with install instructions when pandas is not installed"
    - "Non-paginated response classes (MarketsResponse, EventsResponse, CandlesResponse, SettlementsResponse) each expose .to_df()"
    - "PageIterator is importable from kalshibook top-level package"
  artifacts:
    - path: "sdk/src/kalshibook/_pagination.py"
      provides: "PageIterator class and _records_to_df helper"
      contains: "class PageIterator"
    - path: "sdk/src/kalshibook/models.py"
      provides: ".to_df() method on list response classes"
      contains: "def to_df"
    - path: "sdk/src/kalshibook/__init__.py"
      provides: "PageIterator export"
      contains: "PageIterator"
  key_links:
    - from: "sdk/src/kalshibook/models.py"
      to: "sdk/src/kalshibook/_pagination.py"
      via: "import _records_to_df"
      pattern: "from kalshibook._pagination import _records_to_df"
    - from: "sdk/src/kalshibook/__init__.py"
      to: "sdk/src/kalshibook/_pagination.py"
      via: "re-export PageIterator"
      pattern: "from kalshibook._pagination import PageIterator"
---

<objective>
Implement the PageIterator auto-pagination class, the shared DataFrame conversion helper, and add .to_df() to all list response models.

Purpose: Provides the core pagination and DataFrame infrastructure that client endpoint methods (Plan 11-02) will use. PageIterator is the class users interact with when iterating paginated results.

Output: Filled `_pagination.py` with PageIterator + _records_to_df, updated `models.py` with .to_df() on 4 response classes, updated `__init__.py` with PageIterator export.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-pagination-dataframe-support/11-RESEARCH.md
@sdk/src/kalshibook/_pagination.py
@sdk/src/kalshibook/models.py
@sdk/src/kalshibook/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PageIterator class and _records_to_df helper</name>
  <files>sdk/src/kalshibook/_pagination.py</files>
  <action>
Fill the empty `_pagination.py` stub with:

1. **`_records_to_df(records: list) -> Any`** helper function:
   - Lazy `import pandas as pd` inside the function body (try/except ImportError)
   - On ImportError, raise with message: `"pandas is required for .to_df(). Install with: pip install kalshibook[pandas]"`
   - Use `from None` to suppress the chained exception
   - If `records` is empty, return `pd.DataFrame()`
   - Otherwise return `pd.DataFrame([asdict(r) for r in records])` using `dataclasses.asdict`

2. **`PageIterator[T]`** generic class:
   - Type parameter `T` via `TypeVar("T")`
   - Constructor `__init__(self, items: list[T], has_more: bool, next_cursor: str | None, fetch_page: SyncFetcher | None = None, afetch_page: AsyncFetcher | None = None)`
   - Internal state: `_items` (current page), `_index` (position in page), `_has_more`, `_next_cursor`, `_fetch_page`, `_afetch_page`, `_consumed: list[T]` (tracks ALL yielded items for .to_df())
   - Type aliases at module level:
     - `SyncFetcher = Callable[[str | None], tuple[list[T], bool, str | None]]`
     - `AsyncFetcher = Callable[[str | None], Coroutine[Any, Any, tuple[list[T], bool, str | None]]]`
   - **Sync iteration** (`__iter__` returns self, `__next__`):
     - When `_index >= len(_items)`: if `not _has_more` raise StopIteration; if `_fetch_page is None` raise RuntimeError("Synchronous iteration requires a sync client (sync=True)"); otherwise call `_fetch_page(_next_cursor)` and reset `_index = 0`
     - Yield item at `_index`, increment `_index`, append to `_consumed`
   - **Async iteration** (`__aiter__` returns self, `__anext__`):
     - Same logic but use `await _afetch_page(...)`, raise StopAsyncIteration, RuntimeError message: "Async iteration requires an async client (sync=False)"
     - Append to `_consumed` same as sync
   - **`to_df(self) -> Any`**:
     - Call `list(self)` to drain remaining items (which appends to `_consumed` via `__next__`)
     - Pass `self._consumed` to `_records_to_df()` and return result
     - This way `.to_df()` always returns ALL records, even those already iterated

Include proper docstrings on the class and public methods. Use `from __future__ import annotations` at top. Import `Generic`, `TypeVar`, `Iterator`, `AsyncIterator`, `Callable`, `Coroutine`, `Any` from typing.
  </action>
  <verify>
Run `python -c "from kalshibook._pagination import PageIterator, _records_to_df; print('OK')"` from the sdk directory.
  </verify>
  <done>PageIterator class exists with __iter__, __next__, __aiter__, __anext__, to_df methods. _records_to_df exists with lazy pandas import guard.</done>
</task>

<task type="auto">
  <name>Task 2: Add .to_df() to non-paginated list response classes</name>
  <files>sdk/src/kalshibook/models.py</files>
  <action>
Add a `to_df(self) -> Any` method to each of the following 4 response classes in `models.py`:
- `MarketsResponse`
- `EventsResponse`
- `CandlesResponse`
- `SettlementsResponse`

Each method body is identical -- a two-liner:
```python
def to_df(self) -> Any:
    """Convert records to a pandas DataFrame.

    Requires pandas: ``pip install kalshibook[pandas]``
    """
    from kalshibook._pagination import _records_to_df
    return _records_to_df(self.data)
```

Add `from typing import Any` to the imports at the top of models.py (needed for the return type annotation). The `Any` import avoids depending on pandas types at import time.

Do NOT add `to_df()` to single-item response classes (OrderbookResponse, MarketDetailResponse, EventDetailResponse, SettlementResponse) -- only list responses.
  </action>
  <verify>
Run `python -c "from kalshibook.models import MarketsResponse, SettlementsResponse; print(hasattr(MarketsResponse, 'to_df'), hasattr(SettlementsResponse, 'to_df'))"` -- should print `True True`.
  </verify>
  <done>MarketsResponse, EventsResponse, CandlesResponse, and SettlementsResponse each have a .to_df() method that delegates to _records_to_df.</done>
</task>

<task type="auto">
  <name>Task 3: Export PageIterator from kalshibook package</name>
  <files>sdk/src/kalshibook/__init__.py</files>
  <action>
Update `__init__.py` to export `PageIterator`:

1. Add import: `from kalshibook._pagination import PageIterator`
2. Add `"PageIterator"` to the `__all__` list

Place the import after the existing `KalshiBook` import and before the exceptions imports.
  </action>
  <verify>
Run `python -c "from kalshibook import PageIterator; print(PageIterator)"` -- should print the class.
  </verify>
  <done>PageIterator is importable from the top-level kalshibook package and listed in __all__.</done>
</task>

</tasks>

<verification>
1. `python -c "from kalshibook import PageIterator; print(PageIterator)"` succeeds
2. `python -c "from kalshibook._pagination import PageIterator, _records_to_df"` succeeds
3. `python -c "from kalshibook.models import MarketsResponse, EventsResponse, CandlesResponse, SettlementsResponse; assert all(hasattr(cls, 'to_df') for cls in [MarketsResponse, EventsResponse, CandlesResponse, SettlementsResponse])"` succeeds
4. `cd sdk && uv run pytest tests/test_import.py -v` passes (existing import tests still work)
</verification>

<success_criteria>
- PageIterator[T] implements both sync and async iterator protocols
- _consumed list tracks all yielded items for to_df() completeness
- _records_to_df uses lazy pandas import with helpful ImportError message
- 4 list response classes have .to_df() delegating to shared helper
- PageIterator exported from kalshibook package top-level
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-pagination-dataframe-support/11-01-SUMMARY.md`
</output>
