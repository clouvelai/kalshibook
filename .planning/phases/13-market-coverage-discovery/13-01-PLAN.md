---
phase: 13-market-coverage-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260218000001_create_coverage_matview.sql
  - src/api/routes/coverage.py
  - src/api/models.py
  - src/api/main.py
autonomous: true

must_haves:
  truths:
    - "Coverage stats are served from a pre-computed materialized view, not live partition scans"
    - "Coverage segments reflect actual data gaps -- a market with data on days 1-3 and 7-10 shows two segments, not one range of 1-10"
    - "GET /coverage/stats returns per-market coverage segments with snapshot/delta/trade counts grouped by event"
    - "Materialized view can be refreshed concurrently without blocking reads"
  artifacts:
    - path: "supabase/migrations/20260218000001_create_coverage_matview.sql"
      provides: "Materialized view with gaps-and-islands segment detection + unique index + refresh function"
      contains: "CREATE MATERIALIZED VIEW market_coverage_stats"
    - path: "src/api/routes/coverage.py"
      provides: "GET /coverage/stats endpoint and POST /coverage/refresh admin endpoint"
      exports: ["router"]
    - path: "src/api/models.py"
      provides: "CoverageSegment, MarketCoverage, EventCoverageGroup, CoverageStatsResponse, CoverageSummary response models"
      contains: "class CoverageStatsResponse"
  key_links:
    - from: "src/api/routes/coverage.py"
      to: "market_coverage_stats"
      via: "asyncpg query on materialized view"
      pattern: "market_coverage_stats"
    - from: "src/api/main.py"
      to: "src/api/routes/coverage.py"
      via: "app.include_router"
      pattern: "coverage\\.router"
---

<objective>
Create the backend infrastructure for market coverage discovery: a PostgreSQL materialized view that pre-computes coverage segments using the gaps-and-islands SQL pattern, and a FastAPI endpoint that serves the data grouped by event for the dashboard.

Purpose: Enable fast (<2s) coverage data loading from pre-computed stats rather than live partition scans across snapshots, deltas, and trades tables (COVR-04, COVR-05).
Output: SQL migration, FastAPI endpoint, Pydantic response models.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-market-coverage-discovery/13-RESEARCH.md
@src/api/routes/markets.py
@src/api/models.py
@src/api/deps.py
@src/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create materialized view migration with gaps-and-islands segment detection</name>
  <files>supabase/migrations/20260218000001_create_coverage_matview.sql</files>
  <action>
Create a SQL migration that:

1. Creates a materialized view `market_coverage_stats` using the gaps-and-islands pattern:
   - CTE `data_dates`: UNION ALL distinct dates from snapshots (captured_at::date), deltas (ts::date), and trades (ts::date) per market_ticker
   - CTE `distinct_dates`: SELECT DISTINCT market_ticker, data_date from data_dates
   - CTE `with_boundaries`: Use LAG(data_date) OVER (PARTITION BY market_ticker ORDER BY data_date) to detect gaps > 1 day
   - CTE `with_segments`: Use SUM(is_boundary) OVER (...) to assign segment_id per market
   - CTE `segments`: GROUP BY market_ticker, segment_id to get segment_start (MIN), segment_end (MAX), days_covered (COUNT)
   - Final SELECT joins segments with correlated subqueries for per-segment counts:
     - snapshot_count: COUNT(*) FROM snapshots WHERE market_ticker matches AND captured_at::date BETWEEN segment_start AND segment_end
     - delta_count: COUNT(*) FROM deltas WHERE market_ticker matches AND ts::date BETWEEN segment_start AND segment_end
     - trade_count: COUNT(*) FROM trades WHERE market_ticker matches AND ts::date BETWEEN segment_start AND segment_end
   - WITH DATA (populate immediately)

2. Create unique index for CONCURRENTLY refresh support:
   `CREATE UNIQUE INDEX idx_coverage_stats_pk ON market_coverage_stats (market_ticker, segment_id);`

3. Create a secondary index on market_ticker for fast lookups:
   `CREATE INDEX idx_coverage_stats_ticker ON market_coverage_stats (market_ticker);`

4. Create a refresh function with advisory lock to prevent concurrent refresh conflicts:
   ```sql
   CREATE OR REPLACE FUNCTION refresh_coverage_stats()
   RETURNS void AS $$
   BEGIN
       -- Advisory lock prevents concurrent refresh attempts
       IF NOT pg_try_advisory_lock(hashtext('refresh_coverage_stats')) THEN
           RAISE NOTICE 'Coverage stats refresh already in progress, skipping';
           RETURN;
       END IF;
       BEGIN
           REFRESH MATERIALIZED VIEW CONCURRENTLY market_coverage_stats;
       EXCEPTION WHEN OTHERS THEN
           PERFORM pg_advisory_unlock(hashtext('refresh_coverage_stats'));
           RAISE;
       END;
       PERFORM pg_advisory_unlock(hashtext('refresh_coverage_stats'));
   END;
   $$ LANGUAGE plpgsql;
   ```

Use `-- Migration: Create coverage materialized view` as the header comment.
  </action>
  <verify>
Run `supabase db reset` or apply the migration to verify it executes without errors. Check that `SELECT count(*) FROM market_coverage_stats;` returns results (or 0 if no data exists). Verify `SELECT refresh_coverage_stats();` completes without error.
  </verify>
  <done>
Materialized view exists with gaps-and-islands segment detection, unique index supports CONCURRENTLY refresh, advisory-lock-protected refresh function works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI coverage endpoint and Pydantic response models</name>
  <files>
    src/api/routes/coverage.py
    src/api/models.py
    src/api/main.py
  </files>
  <action>
**In src/api/models.py**, add these response models after the existing Settlements section:

```python
# ---------------------------------------------------------------------------
# Response models -- Coverage
# ---------------------------------------------------------------------------

class CoverageSegment(BaseModel):
    """A contiguous date range with data for a market."""
    segment_id: int = Field(description="Segment identifier within this market")
    segment_start: str = Field(description="First date with data in this segment (YYYY-MM-DD)")
    segment_end: str = Field(description="Last date with data in this segment (YYYY-MM-DD)")
    days_covered: int = Field(description="Number of days with data in this segment")
    snapshot_count: int = Field(description="Number of snapshots in this segment")
    delta_count: int = Field(description="Number of deltas in this segment")
    trade_count: int = Field(description="Number of trades in this segment")

class MarketCoverage(BaseModel):
    """Coverage info for a single market."""
    ticker: str
    title: str | None = None
    status: str | None = None
    segment_count: int = Field(description="Number of contiguous coverage segments")
    total_snapshots: int = Field(description="Total snapshots across all segments")
    total_deltas: int = Field(description="Total deltas across all segments")
    total_trades: int = Field(description="Total trades across all segments")
    first_date: str | None = Field(default=None, description="Earliest coverage date (YYYY-MM-DD)")
    last_date: str | None = Field(default=None, description="Latest coverage date (YYYY-MM-DD)")
    segments: list[CoverageSegment] = Field(description="Contiguous coverage segments")

class EventCoverageGroup(BaseModel):
    """An event with its markets' coverage data."""
    event_ticker: str
    event_title: str | None = None
    market_count: int
    markets: list[MarketCoverage]

class CoverageSummary(BaseModel):
    """Page-level summary stats."""
    total_markets: int = Field(description="Number of markets with any data")
    total_snapshots: int = Field(description="Sum of snapshots across all markets")
    total_deltas: int = Field(description="Sum of deltas across all markets")
    date_range_start: str | None = Field(default=None, description="Earliest data date across all markets")
    date_range_end: str | None = Field(default=None, description="Latest data date across all markets")

class CoverageStatsResponse(BaseModel):
    """Coverage stats grouped by event."""
    summary: CoverageSummary
    events: list[EventCoverageGroup]
    total_events: int = Field(description="Total event count (for pagination)")
    request_id: str
    response_time: float
```

**Create src/api/routes/coverage.py** with:

1. `GET /coverage/stats` endpoint:
   - Auth: `get_authenticated_user` (JWT, no credits -- dashboard-internal)
   - Query params: `search: str | None`, `status: str | None`, `event_ticker: str | None`, `page: int = 1`, `page_size: int = 20`
   - Query the `market_coverage_stats` materialized view, JOIN with `markets` table (for title, status, event_ticker) and `events` table (for event title)
   - Apply filters: `search` does ILIKE on market ticker or title, `status` filters by market status, `event_ticker` filters by event
   - Group results by event_ticker in Python (build EventCoverageGroup objects)
   - Compute CoverageSummary from aggregated data (total markets, total snapshots, total deltas, date range)
   - Paginate at the event group level: skip (page-1)*page_size events, take page_size events
   - Markets with NULL event_ticker go into an "Ungrouped" pseudo-event at the bottom
   - Return CoverageStatsResponse

2. `POST /coverage/refresh` endpoint:
   - Auth: `get_authenticated_user` (JWT, dashboard-internal)
   - Calls `SELECT refresh_coverage_stats()` on the database
   - Returns `{"message": "Coverage stats refreshed", "request_id": "..."}`

Use the existing patterns: `router = APIRouter(tags=["Coverage"])`, `time.monotonic()` for response timing, `request.state.request_id` for request ID.

**In src/api/main.py**:
- Add `from src.api.routes import ... coverage` to the existing import
- Add `app.include_router(coverage.router)` after the billing router
- Add a "Coverage" tag to `openapi_tags`: `{"name": "Coverage", "description": "Market data coverage discovery and segment stats."}`
  </action>
  <verify>
Start the API server (`uv run uvicorn src.api.main:app --reload`) and verify:
- `curl -H "Authorization: Bearer <jwt>" http://localhost:8000/coverage/stats` returns a CoverageStatsResponse with summary and events array
- `curl -X POST -H "Authorization: Bearer <jwt>" http://localhost:8000/coverage/refresh` returns success message
- Search filter: `/coverage/stats?search=INX` filters results
- Status filter: `/coverage/stats?status=active` filters results
  </verify>
  <done>
GET /coverage/stats returns event-grouped coverage data from the materialized view with search/filter/pagination. POST /coverage/refresh triggers a concurrent mat view refresh. Both use JWT auth, no credits deducted.
  </done>
</task>

</tasks>

<verification>
1. Migration applies cleanly: `supabase db reset` completes without error
2. Materialized view populates: `SELECT count(*) FROM market_coverage_stats` returns >= 0
3. Concurrent refresh works: `SELECT refresh_coverage_stats()` completes without error
4. API endpoint responds: GET /coverage/stats returns valid JSON with summary and events
5. Refresh endpoint works: POST /coverage/refresh returns 200
6. No credit deduction: Coverage endpoints use JWT auth only
</verification>

<success_criteria>
- Materialized view exists with gaps-and-islands segment detection
- Unique index enables CONCURRENTLY refresh
- Advisory lock prevents concurrent refresh conflicts
- GET /coverage/stats returns per-market coverage grouped by event
- Search, status, and event_ticker filters work
- Event-level pagination returns correct page count
- Response models match frontend expectations
</success_criteria>

<output>
After completion, create `.planning/phases/13-market-coverage-discovery/13-01-SUMMARY.md`
</output>
