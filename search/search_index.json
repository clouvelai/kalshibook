{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"KalshiBook Python SDK","text":"<p>L2 orderbook data for Kalshi prediction markets.</p> <p>KalshiBook provides a typed Python SDK for accessing historical and real-time orderbook data on Kalshi prediction markets. Query orderbook snapshots, trades, OHLCV candles, market metadata, event hierarchies, and settlement records through a simple, well-documented API.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Typed responses -- All API responses are frozen dataclasses with full type annotations</li> <li>Sync and async -- Use <code>KalshiBook(api_key, sync=True)</code> or <code>sync=False</code> for async workflows</li> <li>Auto-pagination -- <code>PageIterator</code> handles multi-page results transparently</li> <li>DataFrame support -- Call <code>.to_df()</code> on any response or paginated iterator to get a pandas DataFrame</li> <li>Comprehensive error handling -- Typed exceptions for auth errors, rate limits, and missing data</li> </ul>"},{"location":"#installation","title":"Installation","text":"StandardWith pandas support <pre><code>pip install kalshibook\n</code></pre> <pre><code>pip install kalshibook[pandas]\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\n# Reconstruct an orderbook at a point in time\nbook = client.get_orderbook(\n    \"KXBTC-25FEB14-T98250\",\n    timestamp=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n)\nfor level in book.yes[:5]:\n    print(f\"  YES {level.price}c  x{level.quantity}\")\n\n# List available markets as a DataFrame\nmarkets = client.list_markets()\ndf = markets.to_df()\nprint(df[[\"ticker\", \"title\", \"status\"]])\n\nclient.close()\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started -- Full setup and first queries</li> <li>Authentication -- API key configuration and environment variables</li> <li>API Reference -- Complete SDK reference generated from source</li> </ul>"},{"location":"authentication/","title":"Authentication","text":"<p>This guide covers all methods for authenticating with the KalshiBook API, including best practices for keeping your credentials secure.</p>"},{"location":"authentication/#api-key-format","title":"API Key Format","text":"<p>KalshiBook API keys always start with the <code>kb-</code> prefix:</p> <pre><code>kb-a1b2c3d4e5f6...\n</code></pre> <p>Keys are generated from your KalshiBook dashboard. Each key is tied to your account and metered for credit usage.</p>"},{"location":"authentication/#authentication-methods","title":"Authentication Methods","text":""},{"location":"authentication/#direct-key","title":"Direct Key","text":"<p>Pass your API key directly when constructing the client:</p> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook(api_key=\"kb-your-api-key\")\n</code></pre> <p>Avoid hardcoded keys</p> <p>Passing keys directly is convenient for quick scripts, but avoid committing hardcoded keys to version control. Prefer environment variables for any shared or production code.</p>"},{"location":"authentication/#environment-variable","title":"Environment Variable","text":"<p>Set the <code>KALSHIBOOK_API_KEY</code> environment variable and use <code>from_env()</code>:</p> <pre><code>export KALSHIBOOK_API_KEY=\"kb-your-api-key\"\n</code></pre> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook.from_env()\n</code></pre> <p><code>from_env()</code> reads from the <code>KALSHIBOOK_API_KEY</code> environment variable. You can also pass additional keyword arguments:</p> <pre><code>client = KalshiBook.from_env(timeout=60.0, max_retries=5)\n</code></pre> <p>Using .env files</p> <p>For local development, store your key in a <code>.env</code> file:</p> <pre><code>KALSHIBOOK_API_KEY=kb-your-api-key\n</code></pre> <p>Load it with python-dotenv before creating the client:</p> <pre><code>from dotenv import load_dotenv\nfrom kalshibook import KalshiBook\n\nload_dotenv()\nclient = KalshiBook.from_env()\n</code></pre>"},{"location":"authentication/#constructor-without-explicit-key","title":"Constructor Without Explicit Key","text":"<p>If you omit <code>api_key</code>, the constructor also falls back to the <code>KALSHIBOOK_API_KEY</code> environment variable:</p> <pre><code># These are equivalent when KALSHIBOOK_API_KEY is set:\nclient = KalshiBook()\nclient = KalshiBook.from_env()\n</code></pre>"},{"location":"authentication/#context-manager-usage","title":"Context Manager Usage","text":"<p>Use context managers for automatic transport cleanup:</p> SyncAsync <pre><code>from kalshibook import KalshiBook\n\nwith KalshiBook(\"kb-your-api-key\") as client:\n    markets = client.list_markets()\n    print(f\"Found {len(markets.data)} markets\")\n# Transport closed automatically\n</code></pre> <pre><code>import asyncio\nfrom kalshibook import KalshiBook\n\nasync def main():\n    async with KalshiBook(\"kb-your-api-key\", sync=False) as client:\n        markets = await client.alist_markets()\n        print(f\"Found {len(markets.data)} markets\")\n    # Transport closed automatically\n\nasyncio.run(main())\n</code></pre> <p>Without a context manager, call <code>close()</code> (sync) or <code>aclose()</code> (async) explicitly:</p> <pre><code>client = KalshiBook(\"kb-your-api-key\")\ntry:\n    markets = client.list_markets()\nfinally:\n    client.close()\n</code></pre>"},{"location":"authentication/#sync-vs-async-mode","title":"Sync vs Async Mode","text":"<p>By default, the client operates in synchronous mode. Set <code>sync=False</code> for async:</p> Sync (default)Async <pre><code>client = KalshiBook(\"kb-your-api-key\")  # sync=True is the default\n\nmarkets = client.list_markets()\nbook = client.get_orderbook(\"TICKER\", timestamp)\n</code></pre> <pre><code>client = KalshiBook(\"kb-your-api-key\", sync=False)\n\nmarkets = await client.alist_markets()\nbook = await client.aget_orderbook(\"TICKER\", timestamp)\n</code></pre> <p>Async method naming</p> <p>All async methods use the <code>a</code> prefix: <code>alist_markets()</code>, <code>aget_orderbook()</code>, <code>alist_trades()</code>, etc.</p>"},{"location":"authentication/#client-options","title":"Client Options","text":"<p>The <code>KalshiBook</code> constructor accepts these parameters:</p> Parameter Type Default Description <code>api_key</code> <code>str</code> <code>None</code> API key (falls back to env var) <code>base_url</code> <code>str</code> <code>https://api.kalshibook.io</code> API base URL <code>sync</code> <code>bool</code> <code>True</code> Use synchronous transport <code>timeout</code> <code>float</code> <code>30.0</code> Request timeout in seconds <code>max_retries</code> <code>int</code> <code>3</code> Max retries for rate-limited requests"},{"location":"authentication/#credit-tracking","title":"Credit Tracking","text":"<p>Every API response includes credit metadata in the <code>meta</code> field:</p> <pre><code>response = client.list_markets()\n\nprint(f\"Credits used: {response.meta.credits_used}\")\nprint(f\"Credits remaining: {response.meta.credits_remaining}\")\nprint(f\"Response time: {response.meta.response_time}s\")\nprint(f\"Request ID: {response.meta.request_id}\")\n</code></pre> <p>Use this to monitor your credit consumption and implement usage-aware logic:</p> <pre><code>from kalshibook import KalshiBook\nfrom kalshibook.exceptions import CreditsExhaustedError\n\nclient = KalshiBook.from_env()\n\nresponse = client.list_markets()\nif response.meta.credits_remaining &lt; 100:\n    print(\"Warning: Running low on credits!\")\n</code></pre>"},{"location":"authentication/#error-handling","title":"Error Handling","text":"<p>The SDK raises typed exceptions for authentication and billing errors:</p> <pre><code>from kalshibook import KalshiBook\nfrom kalshibook.exceptions import (\n    AuthenticationError,\n    CreditsExhaustedError,\n    RateLimitError,\n    MarketNotFoundError,\n    ValidationError,\n)\n\ntry:\n    client = KalshiBook(\"kb-your-api-key\")\n    book = client.get_orderbook(\"KXBTC-25FEB14-T98250\", timestamp)\nexcept AuthenticationError as e:\n    # Invalid or missing API key\n    print(f\"Auth failed: {e.message}\")\n    print(f\"Status: {e.status_code}\")\nexcept CreditsExhaustedError:\n    # Monthly credit limit reached -- not retryable\n    print(\"Credits exhausted. Enable Pay-As-You-Go or upgrade your plan.\")\nexcept RateLimitError:\n    # All retry attempts exhausted (SDK auto-retries 429s)\n    print(\"Rate limited after max retries. Slow down requests.\")\nexcept MarketNotFoundError:\n    # Ticker does not exist or has no data\n    print(\"Market not found.\")\nexcept ValidationError as e:\n    # Invalid parameters (e.g., bad timestamp format)\n    print(f\"Validation error: {e.message}\")\n</code></pre> <p>Auto-retry on rate limits</p> <p>The SDK automatically retries rate-limited requests (HTTP 429) with exponential backoff and jitter. If a <code>Retry-After</code> header is present, it is honored. <code>RateLimitError</code> is only raised after all retry attempts are exhausted.</p>"},{"location":"authentication/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Never hardcode API keys in source files that may be committed to version control</li> <li>Use environment variables or <code>.env</code> files for key storage</li> <li>Add <code>.env</code> to <code>.gitignore</code> to prevent accidental commits</li> <li>Rotate keys periodically from the KalshiBook dashboard</li> <li>Use separate keys for development and production environments</li> <li>Monitor credit usage via <code>response.meta.credits_remaining</code> to detect unexpected consumption</li> </ol>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing KalshiBook, configuring your API key, and making your first queries.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"StandardWith pandas support <pre><code>pip install kalshibook\n</code></pre> <pre><code>pip install kalshibook[pandas]\n</code></pre> <p>pandas is optional</p> <p>The <code>[pandas]</code> extra installs pandas for <code>.to_df()</code> support on responses. The core SDK has no dependency on pandas -- you only need it if you want DataFrame conversion.</p>"},{"location":"getting-started/#get-an-api-key","title":"Get an API Key","text":"<ol> <li>Sign up at kalshibook.io</li> <li>Navigate to your dashboard and generate an API key</li> <li>Your key will start with <code>kb-</code> -- keep it secret</li> </ol> <p>Keep your key safe</p> <p>Never commit API keys to source control. Use environment variables or <code>.env</code> files instead. See the Authentication guide for best practices.</p>"},{"location":"getting-started/#your-first-query","title":"Your First Query","text":"<p>Create a client and fetch an orderbook snapshot:</p> SyncAsync <pre><code>from datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\n# Reconstruct the orderbook at a specific point in time\nbook = client.get_orderbook(\n    \"KXBTC-25FEB14-T98250\",\n    timestamp=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n)\n\nprint(f\"Market: {book.market_ticker}\")\nprint(f\"Snapshot basis: {book.snapshot_basis}\")\nprint(f\"Deltas applied: {book.deltas_applied}\")\n\n# Print top 5 Yes levels\nfor level in book.yes[:5]:\n    print(f\"  YES {level.price}c  x{level.quantity}\")\n\n# Print top 5 No levels\nfor level in book.no[:5]:\n    print(f\"  NO  {level.price}c  x{level.quantity}\")\n\nclient.close()\n</code></pre> <pre><code>import asyncio\nfrom datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nasync def main():\n    client = KalshiBook(\"kb-your-api-key\", sync=False)\n\n    book = await client.aget_orderbook(\n        \"KXBTC-25FEB14-T98250\",\n        timestamp=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n    )\n\n    print(f\"Market: {book.market_ticker}\")\n    for level in book.yes[:5]:\n        print(f\"  YES {level.price}c  x{level.quantity}\")\n\n    await client.aclose()\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#list-available-markets","title":"List Available Markets","text":"<p>Browse all markets tracked by KalshiBook:</p> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nmarkets = client.list_markets()\n\nfor market in markets.data:\n    print(f\"{market.ticker}: {market.title} [{market.status}]\")\n\nclient.close()\n</code></pre>"},{"location":"getting-started/#convert-to-dataframe","title":"Convert to DataFrame","text":"<p>Any list response supports <code>.to_df()</code> for conversion to a pandas DataFrame:</p> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nmarkets = client.list_markets()\ndf = markets.to_df()\n\nprint(df[[\"ticker\", \"title\", \"status\"]].head(10))\n</code></pre> <p>Install pandas first</p> <p>DataFrame support requires the pandas extra: <pre><code>pip install kalshibook[pandas]\n</code></pre></p>"},{"location":"getting-started/#using-a-context-manager","title":"Using a Context Manager","text":"<p>The client supports context manager syntax for automatic cleanup:</p> <pre><code>from datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nwith KalshiBook(\"kb-your-api-key\") as client:\n    book = client.get_orderbook(\n        \"KXBTC-25FEB14-T98250\",\n        timestamp=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n    )\n    print(f\"Yes levels: {len(book.yes)}, No levels: {len(book.no)}\")\n# Transport is automatically closed here\n</code></pre>"},{"location":"getting-started/#credit-tracking","title":"Credit Tracking","text":"<p>Every response includes metadata about credit usage:</p> <pre><code>markets = client.list_markets()\n\nprint(f\"Credits used: {markets.meta.credits_used}\")\nprint(f\"Credits remaining: {markets.meta.credits_remaining}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication -- API key configuration, environment variables, and security best practices</li> <li>Examples -- Complete code examples for every endpoint</li> <li>API Reference -- Full SDK reference generated from source</li> </ul>"},{"location":"examples/candles/","title":"Candles","text":"<p>Retrieve OHLCV (Open, High, Low, Close, Volume) candlestick data for any market over a time range.</p>"},{"location":"examples/candles/#basic-usage","title":"Basic Usage","text":"<pre><code>from datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\ncandles = client.get_candles(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=datetime(2025, 2, 13, 0, 0, tzinfo=timezone.utc),\n    end_time=datetime(2025, 2, 14, 0, 0, tzinfo=timezone.utc),\n    interval=\"1h\",\n)\n\nfor candle in candles.data:\n    print(\n        f\"{candle.bucket}: \"\n        f\"O={candle.open} H={candle.high} L={candle.low} C={candle.close} \"\n        f\"V={candle.volume} trades={candle.trade_count}\"\n    )\n</code></pre>"},{"location":"examples/candles/#interval-options","title":"Interval Options","text":"<p>The <code>interval</code> parameter controls the candle width. Common values:</p> Interval Description <code>\"1m\"</code> 1 minute <code>\"5m\"</code> 5 minutes <code>\"15m\"</code> 15 minutes <code>\"1h\"</code> 1 hour <code>\"4h\"</code> 4 hours <code>\"1d\"</code> 1 day <p>The server validates interval values, so new intervals may be added without SDK updates.</p> <pre><code># Hourly candles (default)\nhourly = client.get_candles(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=start,\n    end_time=end,\n    interval=\"1h\",\n)\n\n# 1-minute candles for high-resolution analysis\nminute = client.get_candles(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=start,\n    end_time=end,\n    interval=\"1m\",\n)\n</code></pre>"},{"location":"examples/candles/#convert-to-dataframe","title":"Convert to DataFrame","text":"<p>Candle data is naturally tabular, making DataFrame conversion especially useful:</p> <pre><code>candles = client.get_candles(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=datetime(2025, 2, 13, 0, 0, tzinfo=timezone.utc),\n    end_time=datetime(2025, 2, 14, 0, 0, tzinfo=timezone.utc),\n    interval=\"1h\",\n)\n\ndf = candles.to_df()\nprint(df[[\"bucket\", \"open\", \"high\", \"low\", \"close\", \"volume\"]])\n</code></pre> <p>Tip</p> <p>DataFrame conversion requires <code>pip install kalshibook[pandas]</code>.</p>"},{"location":"examples/candles/#candlerecord-fields","title":"CandleRecord Fields","text":"Field Type Description <code>bucket</code> <code>datetime</code> Start of the candle period <code>market_ticker</code> <code>str</code> Market ticker <code>open</code> <code>int</code> Opening price (cents) <code>high</code> <code>int</code> Highest price (cents) <code>low</code> <code>int</code> Lowest price (cents) <code>close</code> <code>int</code> Closing price (cents) <code>volume</code> <code>int</code> Number of contracts traded <code>trade_count</code> <code>int</code> Number of individual trades"},{"location":"examples/candles/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>ticker</code> <code>str</code> required Market ticker <code>start_time</code> <code>datetime</code> required Start of range (inclusive). Naive datetimes assumed UTC. <code>end_time</code> <code>datetime</code> required End of range (exclusive). Naive datetimes assumed UTC. <code>interval</code> <code>str</code> <code>\"1h\"</code> Candle width"},{"location":"examples/dataframes/","title":"DataFrames","text":"<p>Convert any list response or paginated result to a pandas DataFrame with <code>.to_df()</code>.</p>"},{"location":"examples/dataframes/#setup","title":"Setup","text":"<p>DataFrame support requires the <code>pandas</code> extra:</p> <pre><code>pip install kalshibook[pandas]\n</code></pre>"},{"location":"examples/dataframes/#list-responses","title":"List Responses","text":"<p>All list responses (<code>MarketsResponse</code>, <code>CandlesResponse</code>, <code>EventsResponse</code>, <code>SettlementsResponse</code>) support <code>.to_df()</code>:</p> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\n# Markets\nmarkets_df = client.list_markets().to_df()\nprint(markets_df[[\"ticker\", \"title\", \"status\"]].head())\n\n# Events\nevents_df = client.list_events().to_df()\nprint(events_df[[\"event_ticker\", \"title\", \"category\"]].head())\n\n# Settlements\nsettlements_df = client.list_settlements().to_df()\nprint(settlements_df[[\"market_ticker\", \"result\", \"settled_at\"]].head())\n</code></pre>"},{"location":"examples/dataframes/#candle-dataframes","title":"Candle DataFrames","text":"<p>Candle data is naturally tabular -- ideal for time series analysis:</p> <pre><code>from datetime import datetime, timezone\n\ncandles_df = client.get_candles(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=datetime(2025, 2, 13, 0, 0, tzinfo=timezone.utc),\n    end_time=datetime(2025, 2, 14, 0, 0, tzinfo=timezone.utc),\n    interval=\"1h\",\n).to_df()\n\nprint(candles_df[[\"bucket\", \"open\", \"high\", \"low\", \"close\", \"volume\"]])\n</code></pre>"},{"location":"examples/dataframes/#paginated-results","title":"Paginated Results","text":"<p><code>PageIterator</code> (returned by <code>list_deltas()</code> and <code>list_trades()</code>) also supports <code>.to_df()</code>. It drains all remaining pages before converting:</p> <pre><code># All deltas as a DataFrame\ndeltas_df = client.list_deltas(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n    end_time=datetime(2025, 2, 14, 13, 0, tzinfo=timezone.utc),\n).to_df()\n\nprint(f\"Total deltas: {len(deltas_df)}\")\nprint(deltas_df.head())\n\n# All trades as a DataFrame\ntrades_df = client.list_trades(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n    end_time=datetime(2025, 2, 14, 13, 0, tzinfo=timezone.utc),\n).to_df()\n\nprint(f\"Total trades: {len(trades_df)}\")\nprint(trades_df.head())\n</code></pre> <p>Pagination is handled automatically</p> <p><code>.to_df()</code> fetches all remaining pages before building the DataFrame. If you have already partially iterated through the <code>PageIterator</code>, the DataFrame will still contain all records (both previously yielded and remaining).</p>"},{"location":"examples/dataframes/#pandas-operations","title":"Pandas Operations","text":"<p>Once you have a DataFrame, use standard pandas for analysis:</p>"},{"location":"examples/dataframes/#filtering","title":"Filtering","text":"<pre><code>markets_df = client.list_markets().to_df()\n\n# Only open markets\nopen_markets = markets_df[markets_df[\"status\"] == \"open\"]\nprint(f\"Open markets: {len(open_markets)}\")\n\n# Markets in a specific category\ncrypto = markets_df[markets_df[\"category\"] == \"crypto\"]\n</code></pre>"},{"location":"examples/dataframes/#grouping","title":"Grouping","text":"<pre><code># Trades by taker side\ntrades_df = client.list_trades(\n    \"KXBTC-25FEB14-T98250\", start, end\n).to_df()\n\nby_side = trades_df.groupby(\"taker_side\").agg(\n    trades=(\"trade_id\", \"count\"),\n    volume=(\"count\", \"sum\"),\n)\nprint(by_side)\n</code></pre>"},{"location":"examples/dataframes/#time-series","title":"Time Series","text":"<pre><code># Set bucket as index for time series operations\ncandles_df = client.get_candles(\n    \"KXBTC-25FEB14-T98250\",\n    start_time=start,\n    end_time=end,\n    interval=\"1h\",\n).to_df()\n\ncandles_df = candles_df.set_index(\"bucket\")\nprint(candles_df[\"close\"].describe())\n</code></pre>"},{"location":"examples/dataframes/#sorting","title":"Sorting","text":"<pre><code># Sort settlements by settlement time\nsettlements_df = client.list_settlements().to_df()\nsorted_df = settlements_df.sort_values(\"settled_at\", ascending=False)\nprint(sorted_df.head())\n</code></pre>"},{"location":"examples/dataframes/#without-pandas","title":"Without pandas","text":"<p>If pandas is not installed, calling <code>.to_df()</code> raises an <code>ImportError</code> with installation instructions:</p> <pre><code>try:\n    df = client.list_markets().to_df()\nexcept ImportError as e:\n    print(e)  # \"pandas is required for .to_df(). Install with: pip install kalshibook[pandas]\"\n</code></pre> <p>You can always work with the raw dataclass objects without pandas:</p> <pre><code>markets = client.list_markets()\nfor market in markets.data:\n    print(f\"{market.ticker}: {market.title}\")\n</code></pre>"},{"location":"examples/deltas/","title":"Deltas","text":"<p>Retrieve raw orderbook delta events -- the individual order additions, removals, and modifications that change the orderbook over time.</p>"},{"location":"examples/deltas/#basic-usage","title":"Basic Usage","text":"<p><code>list_deltas()</code> returns a <code>PageIterator</code> that automatically fetches subsequent pages:</p> <pre><code>from datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nstart = datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc)\nend = datetime(2025, 2, 14, 13, 0, tzinfo=timezone.utc)\n\nfor delta in client.list_deltas(\"KXBTC-25FEB14-T98250\", start, end):\n    print(\n        f\"[{delta.ts}] seq={delta.seq} \"\n        f\"{delta.side} {delta.price_cents}c \"\n        f\"delta={delta.delta_amount:+d}\"\n    )\n</code></pre>"},{"location":"examples/deltas/#auto-pagination","title":"Auto-Pagination","text":"<p>Delta queries can return thousands of records. The <code>PageIterator</code> handles pagination transparently -- just iterate normally and pages are fetched on demand:</p> <pre><code>deltas = client.list_deltas(\"KXBTC-25FEB14-T98250\", start, end)\n\ncount = 0\nfor delta in deltas:\n    count += 1\n\nprint(f\"Total deltas: {count}\")\n</code></pre> <p>You can control the page size with the <code>limit</code> parameter:</p> <pre><code># Fetch 500 records per page instead of the default 100\ndeltas = client.list_deltas(\n    \"KXBTC-25FEB14-T98250\", start, end,\n    limit=500,\n)\n</code></pre>"},{"location":"examples/deltas/#convert-to-dataframe","title":"Convert to DataFrame","text":"<p>Call <code>.to_df()</code> on the <code>PageIterator</code> to drain all pages and return a DataFrame:</p> <pre><code>df = client.list_deltas(\"KXBTC-25FEB14-T98250\", start, end).to_df()\n\nprint(df.head())\nprint(f\"Total records: {len(df)}\")\n</code></pre> <p>Note</p> <p><code>.to_df()</code> drains all remaining pages before converting. If you have already partially iterated, the DataFrame will still include all records (both previously yielded and remaining).</p> <p>Tip</p> <p>DataFrame conversion requires <code>pip install kalshibook[pandas]</code>.</p>"},{"location":"examples/deltas/#understanding-delta-records","title":"Understanding Delta Records","text":"<p>Each <code>DeltaRecord</code> represents a change to the orderbook at a specific price level:</p> <ul> <li>A positive <code>delta_amount</code> means contracts were added at that price</li> <li>A negative <code>delta_amount</code> means contracts were removed</li> <li><code>side</code> indicates whether the change is on the <code>\"yes\"</code> or <code>\"no\"</code> side</li> </ul> <p>Replaying deltas in sequence from a known snapshot reconstructs the orderbook at any point in time. This is exactly what <code>get_orderbook()</code> does server-side.</p>"},{"location":"examples/deltas/#deltarecord-fields","title":"DeltaRecord Fields","text":"Field Type Description <code>market_ticker</code> <code>str</code> Market ticker <code>ts</code> <code>datetime</code> Timestamp of the delta event <code>seq</code> <code>int</code> Sequence number for ordering <code>price_cents</code> <code>int</code> Price level in cents (1-99) <code>delta_amount</code> <code>int</code> Change in quantity (positive = added, negative = removed) <code>side</code> <code>str</code> Orderbook side (<code>\"yes\"</code> or <code>\"no\"</code>)"},{"location":"examples/deltas/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>ticker</code> <code>str</code> required Market ticker <code>start_time</code> <code>datetime</code> required Start of range (inclusive). Naive datetimes assumed UTC. <code>end_time</code> <code>datetime</code> required End of range (exclusive). Naive datetimes assumed UTC. <code>limit</code> <code>int</code> <code>100</code> Page size"},{"location":"examples/events/","title":"Events","text":"<p>Browse events and their child markets. Events are the top-level grouping on Kalshi -- each event contains one or more individual markets.</p>"},{"location":"examples/events/#understanding-the-hierarchy","title":"Understanding the Hierarchy","text":"<p>Kalshi organizes data in a hierarchy:</p> <pre><code>Series (e.g., \"Bitcoin Price\")\n  \u2514\u2500\u2500 Event (e.g., \"BTC Price on Feb 14, 2025\")\n        \u251c\u2500\u2500 Market (e.g., \"BTC above $98,250\")\n        \u251c\u2500\u2500 Market (e.g., \"BTC above $99,000\")\n        \u2514\u2500\u2500 Market (e.g., \"BTC above $100,000\")\n</code></pre> <p>KalshiBook tracks this hierarchy so you can discover related markets.</p>"},{"location":"examples/events/#list-events","title":"List Events","text":"<p><code>list_events()</code> returns a summary of all tracked events:</p> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nevents = client.list_events()\n\nfor event in events.data:\n    print(f\"{event.event_ticker}: {event.title} ({event.market_count} markets)\")\n</code></pre>"},{"location":"examples/events/#filter-events","title":"Filter Events","text":"<p>Use optional parameters to narrow results:</p> <pre><code># Filter by category\ncrypto_events = client.list_events(category=\"crypto\")\n\n# Filter by series\nbtc_events = client.list_events(series_ticker=\"KXBTC\")\n\n# Filter by status\nopen_events = client.list_events(status=\"open\")\n\n# Combine filters\nopen_crypto = client.list_events(category=\"crypto\", status=\"open\")\n</code></pre> Parameter Type Description <code>category</code> <code>str \\| None</code> Filter by category slug <code>series_ticker</code> <code>str \\| None</code> Filter by parent series ticker <code>status</code> <code>str \\| None</code> Filter by event status (<code>\"open\"</code>, <code>\"closed\"</code>)"},{"location":"examples/events/#get-event-detail","title":"Get Event Detail","text":"<p><code>get_event()</code> returns full detail for a single event, including its child markets:</p> <pre><code>event_detail = client.get_event(\"KXBTC-25FEB14\")\n\nevent = event_detail.data\nprint(f\"Event: {event.title}\")\nprint(f\"Category: {event.category}\")\nprint(f\"Status: {event.status}\")\nprint(f\"Mutually exclusive: {event.mutually_exclusive}\")\nprint(f\"Markets: {event.market_count}\")\n\n# List all child markets\nfor market in event.markets:\n    print(f\"  {market.ticker}: {market.title} [{market.status}]\")\n</code></pre>"},{"location":"examples/events/#convert-to-dataframe","title":"Convert to DataFrame","text":"<pre><code>events = client.list_events()\ndf = events.to_df()\n\nprint(df[[\"event_ticker\", \"title\", \"category\", \"status\", \"market_count\"]])\n</code></pre> <p>Tip</p> <p>DataFrame conversion requires <code>pip install kalshibook[pandas]</code>.</p>"},{"location":"examples/events/#eventsummary-fields","title":"EventSummary Fields","text":"<p>Returned by <code>list_events()</code>:</p> Field Type Description <code>event_ticker</code> <code>str</code> Event ticker <code>series_ticker</code> <code>str \\| None</code> Parent series ticker <code>title</code> <code>str \\| None</code> Event title <code>sub_title</code> <code>str \\| None</code> Event subtitle <code>category</code> <code>str \\| None</code> Category slug <code>mutually_exclusive</code> <code>bool \\| None</code> Whether markets are mutually exclusive <code>status</code> <code>str \\| None</code> Event status <code>market_count</code> <code>int \\| None</code> Number of child markets"},{"location":"examples/events/#eventdetail-fields","title":"EventDetail Fields","text":"<p>Returned by <code>get_event()</code> -- includes all EventSummary fields plus:</p> Field Type Description <code>markets</code> <code>list[MarketSummary]</code> Child markets belonging to this event"},{"location":"examples/markets/","title":"Markets","text":"<p>Browse available markets and retrieve detailed information for individual markets.</p>"},{"location":"examples/markets/#list-all-markets","title":"List All Markets","text":"<p><code>list_markets()</code> returns a summary of every market tracked by KalshiBook:</p> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nmarkets = client.list_markets()\n\nfor market in markets.data:\n    print(f\"{market.ticker}: {market.title} [{market.status}]\")\n</code></pre>"},{"location":"examples/markets/#get-market-detail","title":"Get Market Detail","text":"<p><code>get_market()</code> returns full detail for a single market, including data coverage statistics:</p> <pre><code>detail = client.get_market(\"KXBTC-25FEB14-T98250\")\n\nmarket = detail.data\nprint(f\"Ticker: {market.ticker}\")\nprint(f\"Title: {market.title}\")\nprint(f\"Event: {market.event_ticker}\")\nprint(f\"Status: {market.status}\")\nprint(f\"Category: {market.category}\")\nprint(f\"Rules: {market.rules}\")\nprint(f\"Strike price: {market.strike_price}\")\nprint(f\"Data from: {market.first_data_at} to {market.last_data_at}\")\nprint(f\"Snapshots: {market.snapshot_count}\")\nprint(f\"Deltas: {market.delta_count}\")\n</code></pre>"},{"location":"examples/markets/#marketsummary-vs-marketdetail","title":"MarketSummary vs MarketDetail","text":"<p><code>list_markets()</code> returns <code>MarketSummary</code> objects with basic fields. <code>get_market()</code> returns a <code>MarketDetail</code> with additional fields:</p> Field MarketSummary MarketDetail <code>ticker</code> Yes Yes <code>title</code> Yes Yes <code>event_ticker</code> Yes Yes <code>status</code> Yes Yes <code>category</code> Yes Yes <code>first_data_at</code> Yes Yes <code>last_data_at</code> Yes Yes <code>rules</code> -- Yes <code>strike_price</code> -- Yes <code>discovered_at</code> -- Yes <code>metadata</code> -- Yes <code>snapshot_count</code> -- Yes <code>delta_count</code> -- Yes"},{"location":"examples/markets/#filter-by-status","title":"Filter by Status","text":"<p>Use <code>get_market()</code> detail to inspect market status, then filter programmatically:</p> <pre><code>markets = client.list_markets()\n\nopen_markets = [m for m in markets.data if m.status == \"open\"]\nprint(f\"Open markets: {len(open_markets)}\")\n\nfor market in open_markets[:5]:\n    print(f\"  {market.ticker}: {market.title}\")\n</code></pre>"},{"location":"examples/markets/#convert-to-dataframe","title":"Convert to DataFrame","text":"<pre><code>markets = client.list_markets()\ndf = markets.to_df()\n\nprint(df[[\"ticker\", \"title\", \"status\", \"category\"]].head(10))\n</code></pre> <p>Tip</p> <p>DataFrame conversion requires <code>pip install kalshibook[pandas]</code>.</p>"},{"location":"examples/markets/#marketsummary-fields","title":"MarketSummary Fields","text":"Field Type Description <code>ticker</code> <code>str</code> Market ticker <code>title</code> <code>str \\| None</code> Human-readable market title <code>event_ticker</code> <code>str \\| None</code> Parent event ticker <code>status</code> <code>str</code> Market status (<code>\"open\"</code>, <code>\"closed\"</code>, etc.) <code>category</code> <code>str \\| None</code> Category slug <code>first_data_at</code> <code>datetime \\| None</code> Earliest captured data timestamp <code>last_data_at</code> <code>datetime \\| None</code> Most recent captured data timestamp"},{"location":"examples/orderbook/","title":"Orderbook","text":"<p>Reconstruct the full L2 orderbook for any Kalshi market at any point in time.</p> <p>KalshiBook captures orderbook snapshots and delta streams, then replays them server-side to rebuild the exact orderbook state at your requested timestamp.</p>"},{"location":"examples/orderbook/#basic-usage","title":"Basic Usage","text":"<pre><code>from datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nbook = client.get_orderbook(\n    \"KXBTC-25FEB14-T98250\",\n    timestamp=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n)\n\nprint(f\"Market: {book.market_ticker}\")\nprint(f\"Timestamp: {book.timestamp}\")\nprint(f\"Snapshot basis: {book.snapshot_basis}\")\nprint(f\"Deltas applied: {book.deltas_applied}\")\n</code></pre>"},{"location":"examples/orderbook/#accessing-price-levels","title":"Accessing Price Levels","text":"<p>The orderbook has two sides: <code>yes</code> and <code>no</code>. Each side is a list of <code>OrderbookLevel</code> objects with <code>price</code> (in cents) and <code>quantity</code> fields:</p> <pre><code># Print Yes side (bids on the \"yes\" outcome)\nprint(\"YES side:\")\nfor level in book.yes:\n    print(f\"  {level.price}c  x{level.quantity}\")\n\n# Print No side (bids on the \"no\" outcome)\nprint(\"NO side:\")\nfor level in book.no:\n    print(f\"  {level.price}c  x{level.quantity}\")\n</code></pre>"},{"location":"examples/orderbook/#limiting-depth","title":"Limiting Depth","text":"<p>Use the <code>depth</code> parameter to limit the number of price levels returned per side:</p> <pre><code>book = client.get_orderbook(\n    \"KXBTC-25FEB14-T98250\",\n    timestamp=datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc),\n    depth=5,  # Top 5 levels per side\n)\n\nprint(f\"Yes levels: {len(book.yes)}\")  # At most 5\nprint(f\"No levels: {len(book.no)}\")    # At most 5\n</code></pre>"},{"location":"examples/orderbook/#how-reconstruction-works","title":"How Reconstruction Works","text":"<p>When you call <code>get_orderbook()</code>, the server:</p> <ol> <li>Finds the nearest snapshot before your requested timestamp</li> <li>Replays all orderbook deltas between that snapshot and your timestamp</li> <li>Returns the reconstructed L2 state</li> </ol> <p>The <code>snapshot_basis</code> field tells you which snapshot was used as the starting point, and <code>deltas_applied</code> shows how many delta events were replayed.</p>"},{"location":"examples/orderbook/#response-fields","title":"Response Fields","text":"Field Type Description <code>market_ticker</code> <code>str</code> The market ticker <code>timestamp</code> <code>datetime</code> Reconstructed point in time <code>snapshot_basis</code> <code>datetime</code> Snapshot used as reconstruction starting point <code>deltas_applied</code> <code>int</code> Number of deltas replayed from snapshot to timestamp <code>yes</code> <code>list[OrderbookLevel]</code> Yes-side price levels <code>no</code> <code>list[OrderbookLevel]</code> No-side price levels <code>meta</code> <code>ResponseMeta</code> Credit and request metadata <p>Each <code>OrderbookLevel</code> has:</p> Field Type Description <code>price</code> <code>int</code> Price in cents (1-99) <code>quantity</code> <code>int</code> Number of contracts at this price"},{"location":"examples/orderbook/#credit-tracking","title":"Credit Tracking","text":"<pre><code>book = client.get_orderbook(\"KXBTC-25FEB14-T98250\", timestamp)\n\nprint(f\"Credits used: {book.meta.credits_used}\")\nprint(f\"Credits remaining: {book.meta.credits_remaining}\")\n</code></pre>"},{"location":"examples/settlements/","title":"Settlements","text":"<p>Retrieve settlement results for resolved markets -- whether they settled \"yes\" or \"no\" and the final payout value.</p>"},{"location":"examples/settlements/#list-settlements","title":"List Settlements","text":"<p><code>list_settlements()</code> returns settlement results with optional filters:</p> <pre><code>from kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nsettlements = client.list_settlements()\n\nfor s in settlements.data:\n    print(\n        f\"{s.market_ticker}: result={s.result} \"\n        f\"value={s.settlement_value} \"\n        f\"settled_at={s.settled_at}\"\n    )\n</code></pre>"},{"location":"examples/settlements/#filter-settlements","title":"Filter Settlements","text":"<p>Narrow results by event or outcome:</p> <pre><code># All settlements for a specific event\nevent_settlements = client.list_settlements(event_ticker=\"KXBTC-25FEB14\")\n\nfor s in event_settlements.data:\n    print(f\"  {s.market_ticker}: {s.result}\")\n\n# Only \"yes\" settlements\nyes_settlements = client.list_settlements(result=\"yes\")\n</code></pre> Parameter Type Description <code>event_ticker</code> <code>str \\| None</code> Filter by parent event ticker <code>result</code> <code>str \\| None</code> Filter by settlement result (<code>\"yes\"</code>, <code>\"no\"</code>)"},{"location":"examples/settlements/#get-single-settlement","title":"Get Single Settlement","text":"<p><code>get_settlement()</code> returns the settlement for a specific market:</p> <pre><code>settlement = client.get_settlement(\"KXBTC-25FEB14-T98250\")\n\ns = settlement.data\nprint(f\"Market: {s.market_ticker}\")\nprint(f\"Event: {s.event_ticker}\")\nprint(f\"Result: {s.result}\")\nprint(f\"Settlement value: {s.settlement_value}\")\nprint(f\"Determined at: {s.determined_at}\")\nprint(f\"Settled at: {s.settled_at}\")\n</code></pre>"},{"location":"examples/settlements/#convert-to-dataframe","title":"Convert to DataFrame","text":"<pre><code>settlements = client.list_settlements()\ndf = settlements.to_df()\n\nprint(df[[\"market_ticker\", \"result\", \"settlement_value\", \"settled_at\"]])\n</code></pre> <p>Tip</p> <p>DataFrame conversion requires <code>pip install kalshibook[pandas]</code>.</p>"},{"location":"examples/settlements/#settlementrecord-fields","title":"SettlementRecord Fields","text":"Field Type Description <code>market_ticker</code> <code>str</code> Market ticker <code>event_ticker</code> <code>str \\| None</code> Parent event ticker <code>result</code> <code>str \\| None</code> Settlement result (<code>\"yes\"</code> or <code>\"no\"</code>) <code>settlement_value</code> <code>int \\| None</code> Payout value in cents <code>determined_at</code> <code>datetime \\| None</code> When the result was determined <code>settled_at</code> <code>datetime \\| None</code> When settlement was processed"},{"location":"examples/trades/","title":"Trades","text":"<p>Retrieve individual trade records for any market over a time range.</p>"},{"location":"examples/trades/#basic-usage","title":"Basic Usage","text":"<p><code>list_trades()</code> returns a <code>PageIterator</code> that automatically fetches subsequent pages:</p> <pre><code>from datetime import datetime, timezone\nfrom kalshibook import KalshiBook\n\nclient = KalshiBook(\"kb-your-api-key\")\n\nstart = datetime(2025, 2, 14, 12, 0, tzinfo=timezone.utc)\nend = datetime(2025, 2, 14, 13, 0, tzinfo=timezone.utc)\n\nfor trade in client.list_trades(\"KXBTC-25FEB14-T98250\", start, end):\n    print(\n        f\"[{trade.ts}] {trade.trade_id} \"\n        f\"yes={trade.yes_price}c no={trade.no_price}c \"\n        f\"x{trade.count} taker={trade.taker_side}\"\n    )\n</code></pre>"},{"location":"examples/trades/#auto-pagination","title":"Auto-Pagination","text":"<p>Trade queries can return large result sets. The <code>PageIterator</code> handles pagination transparently:</p> <pre><code>trades = client.list_trades(\"KXBTC-25FEB14-T98250\", start, end)\n\ntotal_volume = 0\nfor trade in trades:\n    total_volume += trade.count\n\nprint(f\"Total volume: {total_volume} contracts\")\n</code></pre> <p>Control the page size with <code>limit</code>:</p> <pre><code>trades = client.list_trades(\n    \"KXBTC-25FEB14-T98250\", start, end,\n    limit=500,\n)\n</code></pre>"},{"location":"examples/trades/#convert-to-dataframe","title":"Convert to DataFrame","text":"<pre><code>df = client.list_trades(\"KXBTC-25FEB14-T98250\", start, end).to_df()\n\nprint(df.head())\nprint(f\"Total trades: {len(df)}\")\n\n# Analyze by taker side\nprint(df.groupby(\"taker_side\")[\"count\"].sum())\n</code></pre> <p>Note</p> <p><code>.to_df()</code> drains all remaining pages before converting. If you have already partially iterated, the DataFrame will still include all records.</p> <p>Tip</p> <p>DataFrame conversion requires <code>pip install kalshibook[pandas]</code>.</p>"},{"location":"examples/trades/#understanding-trade-records","title":"Understanding Trade Records","text":"<p>Each trade record contains:</p> <ul> <li><code>yes_price</code> / <code>no_price</code>: The price in cents for each side. These always sum to 100 (e.g., yes=65c, no=35c).</li> <li><code>count</code>: Number of contracts in the trade.</li> <li><code>taker_side</code>: Whether the taker (aggressor) was on the <code>\"yes\"</code> or <code>\"no\"</code> side.</li> </ul>"},{"location":"examples/trades/#traderecord-fields","title":"TradeRecord Fields","text":"Field Type Description <code>trade_id</code> <code>str</code> Unique trade identifier <code>market_ticker</code> <code>str</code> Market ticker <code>yes_price</code> <code>int</code> Yes-side price in cents <code>no_price</code> <code>int</code> No-side price in cents <code>count</code> <code>int</code> Number of contracts <code>taker_side</code> <code>str</code> Taker side (<code>\"yes\"</code> or <code>\"no\"</code>) <code>ts</code> <code>datetime</code> Trade timestamp"},{"location":"examples/trades/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>ticker</code> <code>str</code> required Market ticker <code>start_time</code> <code>datetime</code> required Start of range (inclusive). Naive datetimes assumed UTC. <code>end_time</code> <code>datetime</code> required End of range (exclusive). Naive datetimes assumed UTC. <code>limit</code> <code>int</code> <code>100</code> Page size"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>kalshibook<ul> <li>client</li> <li>exceptions</li> <li>models</li> </ul> </li> </ul>"},{"location":"reference/kalshibook/","title":"kalshibook","text":""},{"location":"reference/kalshibook/#kalshibook","title":"kalshibook","text":"<p>KalshiBook Python SDK -- L2 orderbook data for Kalshi prediction markets.</p>"},{"location":"reference/kalshibook/#kalshibook.PageIterator","title":"PageIterator","text":"<pre><code>PageIterator(items: list[T], has_more: bool, next_cursor: str | None, fetch_page: SyncFetcher | None = None, afetch_page: AsyncFetcher | None = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Auto-paginating iterator over cursor-based API results.</p> <p>Supports both synchronous (<code>for item in iterator</code>) and asynchronous (<code>async for item in iterator</code>) iteration.  Tracks every yielded item internally so that :meth:<code>to_df</code> always returns the complete result set.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T]</code> <p>Records from the first page (already fetched).</p> required <code>has_more</code> <code>bool</code> <p>Whether additional pages exist after the first page.</p> required <code>next_cursor</code> <code>str | None</code> <p>Cursor for the next page, or <code>None</code> if no more pages.</p> required <code>fetch_page</code> <code>SyncFetcher | None</code> <p>Synchronous page-fetcher used by <code>__next__</code>.</p> <code>None</code> <code>afetch_page</code> <code>AsyncFetcher | None</code> <p>Asynchronous page-fetcher used by <code>__anext__</code>.</p> <code>None</code>"},{"location":"reference/kalshibook/#kalshibook.PageIterator.to_df","title":"to_df","text":"<pre><code>to_df() -&gt; Any\n</code></pre> <p>Materialise all records into a pandas DataFrame.</p> <p>Drains any remaining pages first, then returns a DataFrame containing every record (including those already yielded by iteration).</p> <p>Requires pandas: <code>pip install kalshibook[pandas]</code></p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook","title":"KalshiBook","text":"<pre><code>KalshiBook(api_key: str | None = None, *, base_url: str = 'https://api.kalshibook.io', sync: bool = True, timeout: float = 30.0, max_retries: int = 3)\n</code></pre> <p>Client for the KalshiBook API.</p> <p>Provides sync and async access to historical orderbook data, trades, candles, events, and settlements for Kalshi prediction markets.</p> <p>Usage::</p> <pre><code># Sync (default -- scripts and notebooks)\nclient = KalshiBook(\"kb-your-api-key\")\n\n# From environment variable\nclient = KalshiBook.from_env()\n\n# Async\nclient = KalshiBook(\"kb-your-api-key\", sync=False)\n\n# Context manager\nwith KalshiBook(\"kb-your-api-key\") as client:\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>KalshiBook API key (must start with 'kb-'). If not provided, reads from KALSHIBOOK_API_KEY environment variable.</p> <code>None</code> <code>base_url</code> <code>str</code> <p>API base URL. Default: https://api.kalshibook.io</p> <code>'https://api.kalshibook.io'</code> <code>sync</code> <code>bool</code> <p>If True (default), use synchronous HTTP transport. Set to False for async usage in event loop contexts.</p> <code>True</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds. Default: 30.0</p> <code>30.0</code> <code>max_retries</code> <code>int</code> <p>Maximum retry attempts for rate-limited requests. Default: 3</p> <code>3</code>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(**kwargs: Any) -&gt; KalshiBook\n</code></pre> <p>Create client using KALSHIBOOK_API_KEY environment variable.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the underlying HTTP transport (sync).</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose() -&gt; None\n</code></pre> <p>Close the underlying HTTP transport (async).</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.get_orderbook","title":"get_orderbook","text":"<pre><code>get_orderbook(ticker: str, timestamp: datetime, *, depth: int | None = None) -&gt; OrderbookResponse\n</code></pre> <p>Reconstruct the L2 orderbook for ticker at timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker (e.g. <code>\"KXBTC-24MAR14-T50000\"</code>).</p> required <code>timestamp</code> <code>datetime</code> <p>Point-in-time for the reconstruction.  Timezone-aware recommended; naive datetimes are assumed UTC.</p> required <code>depth</code> <code>int</code> <p>Max price levels per side.  <code>None</code> returns all levels.</p> <code>None</code> <p>Returns:</p> Type Description <code>OrderbookResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the ticker does not exist or has no data at timestamp.</p> <code>ValidationError</code> <p>If the timestamp or depth value is invalid.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.aget_orderbook","title":"aget_orderbook  <code>async</code>","text":"<pre><code>aget_orderbook(ticker: str, timestamp: datetime, *, depth: int | None = None) -&gt; OrderbookResponse\n</code></pre> <p>Async version of :meth:<code>get_orderbook</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.list_markets","title":"list_markets","text":"<pre><code>list_markets() -&gt; MarketsResponse\n</code></pre> <p>List all available markets.</p> <p>Returns:</p> Type Description <code>MarketsResponse</code> <p>Contains a list of :class:<code>MarketSummary</code> items.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.alist_markets","title":"alist_markets  <code>async</code>","text":"<pre><code>alist_markets() -&gt; MarketsResponse\n</code></pre> <p>Async version of :meth:<code>list_markets</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.get_market","title":"get_market","text":"<pre><code>get_market(ticker: str) -&gt; MarketDetailResponse\n</code></pre> <p>Get full detail for a single market.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <p>Returns:</p> Type Description <code>MarketDetailResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the ticker does not exist.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.aget_market","title":"aget_market  <code>async</code>","text":"<pre><code>aget_market(ticker: str) -&gt; MarketDetailResponse\n</code></pre> <p>Async version of :meth:<code>get_market</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.get_candles","title":"get_candles","text":"<pre><code>get_candles(ticker: str, *, start_time: datetime, end_time: datetime, interval: str = '1h') -&gt; CandlesResponse\n</code></pre> <p>Get OHLCV candles for ticker within a time range.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <code>start_time</code> <code>datetime</code> <p>Beginning of the range (inclusive).  Naive datetimes assumed UTC.</p> required <code>end_time</code> <code>datetime</code> <p>End of the range (exclusive).  Naive datetimes assumed UTC.</p> required <code>interval</code> <code>str</code> <p>Candle width.  Common values: <code>\"1m\"</code>, <code>\"1h\"</code>, <code>\"1d\"</code>. Server validates for forward-compatibility.</p> <code>'1h'</code> <p>Returns:</p> Type Description <code>CandlesResponse</code>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.aget_candles","title":"aget_candles  <code>async</code>","text":"<pre><code>aget_candles(ticker: str, *, start_time: datetime, end_time: datetime, interval: str = '1h') -&gt; CandlesResponse\n</code></pre> <p>Async version of :meth:<code>get_candles</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.list_events","title":"list_events","text":"<pre><code>list_events(*, category: str | None = None, series_ticker: str | None = None, status: str | None = None) -&gt; EventsResponse\n</code></pre> <p>List events with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Filter by category slug.</p> <code>None</code> <code>series_ticker</code> <code>str</code> <p>Filter by parent series ticker.</p> <code>None</code> <code>status</code> <code>str</code> <p>Filter by event status (e.g. <code>\"open\"</code>, <code>\"closed\"</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>EventsResponse</code>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.alist_events","title":"alist_events  <code>async</code>","text":"<pre><code>alist_events(*, category: str | None = None, series_ticker: str | None = None, status: str | None = None) -&gt; EventsResponse\n</code></pre> <p>Async version of :meth:<code>list_events</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.get_event","title":"get_event","text":"<pre><code>get_event(event_ticker: str) -&gt; EventDetailResponse\n</code></pre> <p>Get full detail for a single event, including child markets.</p> <p>Parameters:</p> Name Type Description Default <code>event_ticker</code> <code>str</code> <p>Event ticker.</p> required <p>Returns:</p> Type Description <code>EventDetailResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the event ticker does not exist.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.aget_event","title":"aget_event  <code>async</code>","text":"<pre><code>aget_event(event_ticker: str) -&gt; EventDetailResponse\n</code></pre> <p>Async version of :meth:<code>get_event</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.list_settlements","title":"list_settlements","text":"<pre><code>list_settlements(*, event_ticker: str | None = None, result: str | None = None) -&gt; SettlementsResponse\n</code></pre> <p>List settlement results with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>event_ticker</code> <code>str</code> <p>Filter by parent event ticker.</p> <code>None</code> <code>result</code> <code>str</code> <p>Filter by settlement result (e.g. <code>\"yes\"</code>, <code>\"no\"</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>SettlementsResponse</code>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.alist_settlements","title":"alist_settlements  <code>async</code>","text":"<pre><code>alist_settlements(*, event_ticker: str | None = None, result: str | None = None) -&gt; SettlementsResponse\n</code></pre> <p>Async version of :meth:<code>list_settlements</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.get_settlement","title":"get_settlement","text":"<pre><code>get_settlement(ticker: str) -&gt; SettlementResponse\n</code></pre> <p>Get settlement result for a single market.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <p>Returns:</p> Type Description <code>SettlementResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the ticker does not exist or has no settlement.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.aget_settlement","title":"aget_settlement  <code>async</code>","text":"<pre><code>aget_settlement(ticker: str) -&gt; SettlementResponse\n</code></pre> <p>Async version of :meth:<code>get_settlement</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.list_deltas","title":"list_deltas","text":"<pre><code>list_deltas(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[DeltaRecord]\n</code></pre> <p>Iterate orderbook deltas for ticker within a time range.</p> <p>Returns a :class:<code>PageIterator</code> that transparently fetches subsequent pages on demand.  The first page is fetched eagerly so errors surface at call time rather than during iteration.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <code>start_time</code> <code>datetime</code> <p>Beginning of the range (inclusive).  Naive datetimes assumed UTC.</p> required <code>end_time</code> <code>datetime</code> <p>End of the range (exclusive).  Naive datetimes assumed UTC.</p> required <code>limit</code> <code>int</code> <p>Page size.  Default: 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>PageIterator[DeltaRecord]</code> <p>Examples:</p> <p>Iterate all deltas::</p> <pre><code>for delta in client.list_deltas(\"KXBTC-T50\", start, end):\n    print(delta.price_cents, delta.delta_amount)\n</code></pre> <p>Convert to DataFrame::</p> <pre><code>df = client.list_deltas(\"KXBTC-T50\", start, end).to_df()\n</code></pre>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.alist_deltas","title":"alist_deltas  <code>async</code>","text":"<pre><code>alist_deltas(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[DeltaRecord]\n</code></pre> <p>Async version of :meth:<code>list_deltas</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.list_trades","title":"list_trades","text":"<pre><code>list_trades(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[TradeRecord]\n</code></pre> <p>Iterate trades for ticker within a time range.</p> <p>Returns a :class:<code>PageIterator</code> that transparently fetches subsequent pages on demand.  The first page is fetched eagerly so errors surface at call time rather than during iteration.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <code>start_time</code> <code>datetime</code> <p>Beginning of the range (inclusive).  Naive datetimes assumed UTC.</p> required <code>end_time</code> <code>datetime</code> <p>End of the range (exclusive).  Naive datetimes assumed UTC.</p> required <code>limit</code> <code>int</code> <p>Page size.  Default: 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>PageIterator[TradeRecord]</code> <p>Examples:</p> <p>Iterate all trades::</p> <pre><code>for trade in client.list_trades(\"KXBTC-T50\", start, end):\n    print(trade.yes_price, trade.taker_side)\n</code></pre> <p>Convert to DataFrame::</p> <pre><code>df = client.list_trades(\"KXBTC-T50\", start, end).to_df()\n</code></pre>"},{"location":"reference/kalshibook/#kalshibook.KalshiBook.alist_trades","title":"alist_trades  <code>async</code>","text":"<pre><code>alist_trades(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[TradeRecord]\n</code></pre> <p>Async version of :meth:<code>list_trades</code>.</p>"},{"location":"reference/kalshibook/#kalshibook.AuthenticationError","title":"AuthenticationError","text":"<pre><code>AuthenticationError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>API key is missing, malformed, or invalid.</p>"},{"location":"reference/kalshibook/#kalshibook.CreditsExhaustedError","title":"CreditsExhaustedError","text":"<pre><code>CreditsExhaustedError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>Monthly credit limit reached (HTTP 429, code=credits_exhausted).</p> <p>Not retryable. Enable Pay-As-You-Go or upgrade plan.</p>"},{"location":"reference/kalshibook/#kalshibook.KalshiBookError","title":"KalshiBookError","text":"<pre><code>KalshiBookError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for all KalshiBook SDK errors.</p> <p>All SDK exceptions carry contextual information about the failed request:</p> <p>Attributes:     message: Human-readable error description.     status_code: HTTP status code from the API response (0 if not applicable).     response_body: Parsed JSON body from the API error response.</p>"},{"location":"reference/kalshibook/#kalshibook.MarketNotFoundError","title":"MarketNotFoundError","text":"<pre><code>MarketNotFoundError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>The requested market, event, or settlement was not found (HTTP 404).</p>"},{"location":"reference/kalshibook/#kalshibook.RateLimitError","title":"RateLimitError","text":"<pre><code>RateLimitError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>Request was rate-limited (HTTP 429, code=rate_limit_exceeded).</p> <p>The SDK auto-retries these transparently. If you see this exception, all retry attempts were exhausted.</p>"},{"location":"reference/kalshibook/#kalshibook.ValidationError","title":"ValidationError","text":"<pre><code>ValidationError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>Request validation failed (HTTP 422).</p>"},{"location":"reference/kalshibook/client/","title":"client","text":""},{"location":"reference/kalshibook/client/#kalshibook.client","title":"kalshibook.client","text":"<p>KalshiBook client -- query L2 orderbook data for Kalshi prediction markets.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook","title":"KalshiBook","text":"<pre><code>KalshiBook(api_key: str | None = None, *, base_url: str = 'https://api.kalshibook.io', sync: bool = True, timeout: float = 30.0, max_retries: int = 3)\n</code></pre> <p>Client for the KalshiBook API.</p> <p>Provides sync and async access to historical orderbook data, trades, candles, events, and settlements for Kalshi prediction markets.</p> <p>Usage::</p> <pre><code># Sync (default -- scripts and notebooks)\nclient = KalshiBook(\"kb-your-api-key\")\n\n# From environment variable\nclient = KalshiBook.from_env()\n\n# Async\nclient = KalshiBook(\"kb-your-api-key\", sync=False)\n\n# Context manager\nwith KalshiBook(\"kb-your-api-key\") as client:\n    ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>KalshiBook API key (must start with 'kb-'). If not provided, reads from KALSHIBOOK_API_KEY environment variable.</p> <code>None</code> <code>base_url</code> <code>str</code> <p>API base URL. Default: https://api.kalshibook.io</p> <code>'https://api.kalshibook.io'</code> <code>sync</code> <code>bool</code> <p>If True (default), use synchronous HTTP transport. Set to False for async usage in event loop contexts.</p> <code>True</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds. Default: 30.0</p> <code>30.0</code> <code>max_retries</code> <code>int</code> <p>Maximum retry attempts for rate-limited requests. Default: 3</p> <code>3</code>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(**kwargs: Any) -&gt; KalshiBook\n</code></pre> <p>Create client using KALSHIBOOK_API_KEY environment variable.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the underlying HTTP transport (sync).</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose() -&gt; None\n</code></pre> <p>Close the underlying HTTP transport (async).</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.get_orderbook","title":"get_orderbook","text":"<pre><code>get_orderbook(ticker: str, timestamp: datetime, *, depth: int | None = None) -&gt; OrderbookResponse\n</code></pre> <p>Reconstruct the L2 orderbook for ticker at timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker (e.g. <code>\"KXBTC-24MAR14-T50000\"</code>).</p> required <code>timestamp</code> <code>datetime</code> <p>Point-in-time for the reconstruction.  Timezone-aware recommended; naive datetimes are assumed UTC.</p> required <code>depth</code> <code>int</code> <p>Max price levels per side.  <code>None</code> returns all levels.</p> <code>None</code> <p>Returns:</p> Type Description <code>OrderbookResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the ticker does not exist or has no data at timestamp.</p> <code>ValidationError</code> <p>If the timestamp or depth value is invalid.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.aget_orderbook","title":"aget_orderbook  <code>async</code>","text":"<pre><code>aget_orderbook(ticker: str, timestamp: datetime, *, depth: int | None = None) -&gt; OrderbookResponse\n</code></pre> <p>Async version of :meth:<code>get_orderbook</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.list_markets","title":"list_markets","text":"<pre><code>list_markets() -&gt; MarketsResponse\n</code></pre> <p>List all available markets.</p> <p>Returns:</p> Type Description <code>MarketsResponse</code> <p>Contains a list of :class:<code>MarketSummary</code> items.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.alist_markets","title":"alist_markets  <code>async</code>","text":"<pre><code>alist_markets() -&gt; MarketsResponse\n</code></pre> <p>Async version of :meth:<code>list_markets</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.get_market","title":"get_market","text":"<pre><code>get_market(ticker: str) -&gt; MarketDetailResponse\n</code></pre> <p>Get full detail for a single market.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <p>Returns:</p> Type Description <code>MarketDetailResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the ticker does not exist.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.aget_market","title":"aget_market  <code>async</code>","text":"<pre><code>aget_market(ticker: str) -&gt; MarketDetailResponse\n</code></pre> <p>Async version of :meth:<code>get_market</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.get_candles","title":"get_candles","text":"<pre><code>get_candles(ticker: str, *, start_time: datetime, end_time: datetime, interval: str = '1h') -&gt; CandlesResponse\n</code></pre> <p>Get OHLCV candles for ticker within a time range.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <code>start_time</code> <code>datetime</code> <p>Beginning of the range (inclusive).  Naive datetimes assumed UTC.</p> required <code>end_time</code> <code>datetime</code> <p>End of the range (exclusive).  Naive datetimes assumed UTC.</p> required <code>interval</code> <code>str</code> <p>Candle width.  Common values: <code>\"1m\"</code>, <code>\"1h\"</code>, <code>\"1d\"</code>. Server validates for forward-compatibility.</p> <code>'1h'</code> <p>Returns:</p> Type Description <code>CandlesResponse</code>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.aget_candles","title":"aget_candles  <code>async</code>","text":"<pre><code>aget_candles(ticker: str, *, start_time: datetime, end_time: datetime, interval: str = '1h') -&gt; CandlesResponse\n</code></pre> <p>Async version of :meth:<code>get_candles</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.list_events","title":"list_events","text":"<pre><code>list_events(*, category: str | None = None, series_ticker: str | None = None, status: str | None = None) -&gt; EventsResponse\n</code></pre> <p>List events with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> <p>Filter by category slug.</p> <code>None</code> <code>series_ticker</code> <code>str</code> <p>Filter by parent series ticker.</p> <code>None</code> <code>status</code> <code>str</code> <p>Filter by event status (e.g. <code>\"open\"</code>, <code>\"closed\"</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>EventsResponse</code>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.alist_events","title":"alist_events  <code>async</code>","text":"<pre><code>alist_events(*, category: str | None = None, series_ticker: str | None = None, status: str | None = None) -&gt; EventsResponse\n</code></pre> <p>Async version of :meth:<code>list_events</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.get_event","title":"get_event","text":"<pre><code>get_event(event_ticker: str) -&gt; EventDetailResponse\n</code></pre> <p>Get full detail for a single event, including child markets.</p> <p>Parameters:</p> Name Type Description Default <code>event_ticker</code> <code>str</code> <p>Event ticker.</p> required <p>Returns:</p> Type Description <code>EventDetailResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the event ticker does not exist.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.aget_event","title":"aget_event  <code>async</code>","text":"<pre><code>aget_event(event_ticker: str) -&gt; EventDetailResponse\n</code></pre> <p>Async version of :meth:<code>get_event</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.list_settlements","title":"list_settlements","text":"<pre><code>list_settlements(*, event_ticker: str | None = None, result: str | None = None) -&gt; SettlementsResponse\n</code></pre> <p>List settlement results with optional filters.</p> <p>Parameters:</p> Name Type Description Default <code>event_ticker</code> <code>str</code> <p>Filter by parent event ticker.</p> <code>None</code> <code>result</code> <code>str</code> <p>Filter by settlement result (e.g. <code>\"yes\"</code>, <code>\"no\"</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>SettlementsResponse</code>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.alist_settlements","title":"alist_settlements  <code>async</code>","text":"<pre><code>alist_settlements(*, event_ticker: str | None = None, result: str | None = None) -&gt; SettlementsResponse\n</code></pre> <p>Async version of :meth:<code>list_settlements</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.get_settlement","title":"get_settlement","text":"<pre><code>get_settlement(ticker: str) -&gt; SettlementResponse\n</code></pre> <p>Get settlement result for a single market.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <p>Returns:</p> Type Description <code>SettlementResponse</code> <p>Raises:</p> Type Description <code>MarketNotFoundError</code> <p>If the ticker does not exist or has no settlement.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.aget_settlement","title":"aget_settlement  <code>async</code>","text":"<pre><code>aget_settlement(ticker: str) -&gt; SettlementResponse\n</code></pre> <p>Async version of :meth:<code>get_settlement</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.list_deltas","title":"list_deltas","text":"<pre><code>list_deltas(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[DeltaRecord]\n</code></pre> <p>Iterate orderbook deltas for ticker within a time range.</p> <p>Returns a :class:<code>PageIterator</code> that transparently fetches subsequent pages on demand.  The first page is fetched eagerly so errors surface at call time rather than during iteration.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <code>start_time</code> <code>datetime</code> <p>Beginning of the range (inclusive).  Naive datetimes assumed UTC.</p> required <code>end_time</code> <code>datetime</code> <p>End of the range (exclusive).  Naive datetimes assumed UTC.</p> required <code>limit</code> <code>int</code> <p>Page size.  Default: 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>PageIterator[DeltaRecord]</code> <p>Examples:</p> <p>Iterate all deltas::</p> <pre><code>for delta in client.list_deltas(\"KXBTC-T50\", start, end):\n    print(delta.price_cents, delta.delta_amount)\n</code></pre> <p>Convert to DataFrame::</p> <pre><code>df = client.list_deltas(\"KXBTC-T50\", start, end).to_df()\n</code></pre>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.alist_deltas","title":"alist_deltas  <code>async</code>","text":"<pre><code>alist_deltas(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[DeltaRecord]\n</code></pre> <p>Async version of :meth:<code>list_deltas</code>.</p>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.list_trades","title":"list_trades","text":"<pre><code>list_trades(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[TradeRecord]\n</code></pre> <p>Iterate trades for ticker within a time range.</p> <p>Returns a :class:<code>PageIterator</code> that transparently fetches subsequent pages on demand.  The first page is fetched eagerly so errors surface at call time rather than during iteration.</p> <p>Parameters:</p> Name Type Description Default <code>ticker</code> <code>str</code> <p>Market ticker.</p> required <code>start_time</code> <code>datetime</code> <p>Beginning of the range (inclusive).  Naive datetimes assumed UTC.</p> required <code>end_time</code> <code>datetime</code> <p>End of the range (exclusive).  Naive datetimes assumed UTC.</p> required <code>limit</code> <code>int</code> <p>Page size.  Default: 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>PageIterator[TradeRecord]</code> <p>Examples:</p> <p>Iterate all trades::</p> <pre><code>for trade in client.list_trades(\"KXBTC-T50\", start, end):\n    print(trade.yes_price, trade.taker_side)\n</code></pre> <p>Convert to DataFrame::</p> <pre><code>df = client.list_trades(\"KXBTC-T50\", start, end).to_df()\n</code></pre>"},{"location":"reference/kalshibook/client/#kalshibook.client.KalshiBook.alist_trades","title":"alist_trades  <code>async</code>","text":"<pre><code>alist_trades(ticker: str, start_time: datetime, end_time: datetime, *, limit: int = 100) -&gt; PageIterator[TradeRecord]\n</code></pre> <p>Async version of :meth:<code>list_trades</code>.</p>"},{"location":"reference/kalshibook/exceptions/","title":"exceptions","text":""},{"location":"reference/kalshibook/exceptions/#kalshibook.exceptions","title":"kalshibook.exceptions","text":"<p>Exception hierarchy for KalshiBook SDK errors.</p>"},{"location":"reference/kalshibook/exceptions/#kalshibook.exceptions.KalshiBookError","title":"KalshiBookError","text":"<pre><code>KalshiBookError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for all KalshiBook SDK errors.</p> <p>All SDK exceptions carry contextual information about the failed request:</p> <p>Attributes:     message: Human-readable error description.     status_code: HTTP status code from the API response (0 if not applicable).     response_body: Parsed JSON body from the API error response.</p>"},{"location":"reference/kalshibook/exceptions/#kalshibook.exceptions.AuthenticationError","title":"AuthenticationError","text":"<pre><code>AuthenticationError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>API key is missing, malformed, or invalid.</p>"},{"location":"reference/kalshibook/exceptions/#kalshibook.exceptions.RateLimitError","title":"RateLimitError","text":"<pre><code>RateLimitError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>Request was rate-limited (HTTP 429, code=rate_limit_exceeded).</p> <p>The SDK auto-retries these transparently. If you see this exception, all retry attempts were exhausted.</p>"},{"location":"reference/kalshibook/exceptions/#kalshibook.exceptions.CreditsExhaustedError","title":"CreditsExhaustedError","text":"<pre><code>CreditsExhaustedError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>Monthly credit limit reached (HTTP 429, code=credits_exhausted).</p> <p>Not retryable. Enable Pay-As-You-Go or upgrade plan.</p>"},{"location":"reference/kalshibook/exceptions/#kalshibook.exceptions.MarketNotFoundError","title":"MarketNotFoundError","text":"<pre><code>MarketNotFoundError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>The requested market, event, or settlement was not found (HTTP 404).</p>"},{"location":"reference/kalshibook/exceptions/#kalshibook.exceptions.ValidationError","title":"ValidationError","text":"<pre><code>ValidationError(message: str, *, status_code: int = 0, response_body: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>KalshiBookError</code></p> <p>Request validation failed (HTTP 422).</p>"},{"location":"reference/kalshibook/models/","title":"models","text":""},{"location":"reference/kalshibook/models/#kalshibook.models","title":"kalshibook.models","text":"<p>Response models for KalshiBook API data.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.ResponseMeta","title":"ResponseMeta  <code>dataclass</code>","text":"<pre><code>ResponseMeta(credits_used: int, credits_remaining: int, response_time: float, request_id: str)\n</code></pre> <p>Credit and request metadata extracted from API response headers/body.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.ResponseMeta.from_headers","title":"from_headers  <code>classmethod</code>","text":"<pre><code>from_headers(headers: dict, body: dict) -&gt; ResponseMeta\n</code></pre> <p>Parse metadata from httpx response headers and body.</p> <p>Uses -1 as sentinel for missing credit headers (e.g. on error responses).</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.OrderbookLevel","title":"OrderbookLevel  <code>dataclass</code>","text":"<pre><code>OrderbookLevel(price: int, quantity: int)\n</code></pre> <p>A single price level in the orderbook.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.OrderbookResponse","title":"OrderbookResponse  <code>dataclass</code>","text":"<pre><code>OrderbookResponse(market_ticker: str, timestamp: datetime, snapshot_basis: datetime, deltas_applied: int, yes: list[OrderbookLevel], no: list[OrderbookLevel], meta: ResponseMeta)\n</code></pre> <p>Reconstructed orderbook state at a specific timestamp.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.DeltaRecord","title":"DeltaRecord  <code>dataclass</code>","text":"<pre><code>DeltaRecord(market_ticker: str, ts: datetime, seq: int, price_cents: int, delta_amount: int, side: str)\n</code></pre> <p>A single orderbook delta event.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.DeltasResponse","title":"DeltasResponse  <code>dataclass</code>","text":"<pre><code>DeltasResponse(data: list[DeltaRecord], next_cursor: str | None, has_more: bool, meta: ResponseMeta)\n</code></pre> <p>Paginated list of orderbook deltas.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.TradeRecord","title":"TradeRecord  <code>dataclass</code>","text":"<pre><code>TradeRecord(trade_id: str, market_ticker: str, yes_price: int, no_price: int, count: int, taker_side: str, ts: datetime)\n</code></pre> <p>A single trade record.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.TradesResponse","title":"TradesResponse  <code>dataclass</code>","text":"<pre><code>TradesResponse(data: list[TradeRecord], next_cursor: str | None, has_more: bool, meta: ResponseMeta)\n</code></pre> <p>Paginated list of trades.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.MarketSummary","title":"MarketSummary  <code>dataclass</code>","text":"<pre><code>MarketSummary(ticker: str, title: str | None, event_ticker: str | None, status: str, category: str | None, first_data_at: datetime | None, last_data_at: datetime | None)\n</code></pre> <p>Summary info for a market.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.MarketDetail","title":"MarketDetail  <code>dataclass</code>","text":"<pre><code>MarketDetail(ticker: str, title: str | None, event_ticker: str | None, status: str, category: str | None, first_data_at: datetime | None, last_data_at: datetime | None, rules: str | None, strike_price: float | None, discovered_at: datetime, metadata: dict | None, snapshot_count: int, delta_count: int)\n</code></pre> <p>Full detail for a single market (flat, no inheritance).</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.MarketsResponse","title":"MarketsResponse  <code>dataclass</code>","text":"<pre><code>MarketsResponse(data: list[MarketSummary], meta: ResponseMeta)\n</code></pre> <p>List of markets.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.MarketsResponse.to_df","title":"to_df","text":"<pre><code>to_df() -&gt; Any\n</code></pre> <p>Convert records to a pandas DataFrame.</p> <p>Requires pandas: <code>pip install kalshibook[pandas]</code></p>"},{"location":"reference/kalshibook/models/#kalshibook.models.MarketDetailResponse","title":"MarketDetailResponse  <code>dataclass</code>","text":"<pre><code>MarketDetailResponse(data: MarketDetail, meta: ResponseMeta)\n</code></pre> <p>Single market detail.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.CandleRecord","title":"CandleRecord  <code>dataclass</code>","text":"<pre><code>CandleRecord(bucket: datetime, market_ticker: str, open: int, high: int, low: int, close: int, volume: int, trade_count: int)\n</code></pre> <p>OHLCV candle for a market.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.CandlesResponse","title":"CandlesResponse  <code>dataclass</code>","text":"<pre><code>CandlesResponse(data: list[CandleRecord], meta: ResponseMeta)\n</code></pre> <p>List of OHLCV candles.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.CandlesResponse.to_df","title":"to_df","text":"<pre><code>to_df() -&gt; Any\n</code></pre> <p>Convert records to a pandas DataFrame.</p> <p>Requires pandas: <code>pip install kalshibook[pandas]</code></p>"},{"location":"reference/kalshibook/models/#kalshibook.models.SettlementRecord","title":"SettlementRecord  <code>dataclass</code>","text":"<pre><code>SettlementRecord(market_ticker: str, event_ticker: str | None, result: str | None, settlement_value: int | None, determined_at: datetime | None, settled_at: datetime | None)\n</code></pre> <p>Settlement result for a market.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.SettlementResponse","title":"SettlementResponse  <code>dataclass</code>","text":"<pre><code>SettlementResponse(data: SettlementRecord, meta: ResponseMeta)\n</code></pre> <p>Single settlement result.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.SettlementsResponse","title":"SettlementsResponse  <code>dataclass</code>","text":"<pre><code>SettlementsResponse(data: list[SettlementRecord], meta: ResponseMeta)\n</code></pre> <p>List of settlement results.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.SettlementsResponse.to_df","title":"to_df","text":"<pre><code>to_df() -&gt; Any\n</code></pre> <p>Convert records to a pandas DataFrame.</p> <p>Requires pandas: <code>pip install kalshibook[pandas]</code></p>"},{"location":"reference/kalshibook/models/#kalshibook.models.EventSummary","title":"EventSummary  <code>dataclass</code>","text":"<pre><code>EventSummary(event_ticker: str, series_ticker: str | None, title: str | None, sub_title: str | None, category: str | None, mutually_exclusive: bool | None, status: str | None, market_count: int | None)\n</code></pre> <p>Summary info for an event.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.EventDetail","title":"EventDetail  <code>dataclass</code>","text":"<pre><code>EventDetail(event_ticker: str, series_ticker: str | None, title: str | None, sub_title: str | None, category: str | None, mutually_exclusive: bool | None, status: str | None, market_count: int | None, markets: list[MarketSummary])\n</code></pre> <p>Full event detail including child markets (flat, no inheritance).</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.EventsResponse","title":"EventsResponse  <code>dataclass</code>","text":"<pre><code>EventsResponse(data: list[EventSummary], meta: ResponseMeta)\n</code></pre> <p>List of events.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.EventsResponse.to_df","title":"to_df","text":"<pre><code>to_df() -&gt; Any\n</code></pre> <p>Convert records to a pandas DataFrame.</p> <p>Requires pandas: <code>pip install kalshibook[pandas]</code></p>"},{"location":"reference/kalshibook/models/#kalshibook.models.EventDetailResponse","title":"EventDetailResponse  <code>dataclass</code>","text":"<pre><code>EventDetailResponse(data: EventDetail, meta: ResponseMeta)\n</code></pre> <p>Single event with full detail.</p>"},{"location":"reference/kalshibook/models/#kalshibook.models.BillingStatus","title":"BillingStatus  <code>dataclass</code>","text":"<pre><code>BillingStatus(tier: str, credits_total: int, credits_used: int, credits_remaining: int, payg_enabled: bool, billing_cycle_start: datetime)\n</code></pre> <p>Current billing account status.</p>"}]}