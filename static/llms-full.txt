# KalshiBook API

> Historical L2 orderbook data API for Kalshi prediction markets. Query reconstructed orderbook state at any timestamp, raw deltas, and market metadata.

KalshiBook provides programmatic access to historical Kalshi orderbook data for backtesting trading strategies and building automated trading systems. Kalshi is a CFTC-regulated prediction market exchange where markets are binary event contracts with continuous orderbooks.

## Base URL

```
https://api.kalshibook.com
```

## API Reference
- [OpenAPI Spec](/openapi.json): Full API specification (machine-readable)
- [Interactive Docs](/docs): Swagger UI for testing endpoints
- [ReDoc](/redoc): Alternative API documentation

---

## Authentication

### Overview

KalshiBook uses two authentication methods:

1. **Supabase JWT tokens** -- for account management (signup, login, key management)
2. **API keys** -- for all data endpoints (orderbook, deltas, markets, trades, settlements, candles, events)

API keys are prefixed with `kb-` and sent via the Authorization header:
```
Authorization: Bearer kb-YOUR_API_KEY
```

### Getting Started

**Step 1: Create an account**
```bash
curl -X POST /auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "securepassword123"}'
```

Response:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "refresh_token": "v1.MQ...",
  "user_id": "uuid-string",
  "request_id": "req_abc123"
}
```

**Step 2: Create an API key**
```bash
curl -X POST /keys \
  -H "Authorization: Bearer <access_token_from_step_1>" \
  -H "Content-Type: application/json" \
  -d '{"name": "My Trading Bot"}'
```

Response:
```json
{
  "data": {
    "id": "uuid-string",
    "key": "kb-abc123...",
    "name": "My Trading Bot",
    "key_prefix": "kb-abc1",
    "created_at": "2026-01-15T10:30:00Z"
  },
  "request_id": "req_def456"
}
```

**Important:** The raw API key (`kb-...`) is shown only once at creation time. Store it securely.

**Step 3: Use your API key for data queries**
```bash
curl -X POST /orderbook \
  -H "Authorization: Bearer kb-abc123..." \
  -H "Content-Type: application/json" \
  -d '{"market_ticker": "KXBTCD-25FEB14-B97000", "timestamp": "2026-02-14T12:00:00Z"}'
```

---

## Authentication Endpoints

### POST /auth/signup

Create a new user account.

**Request:**
```json
{
  "email": "user@example.com",
  "password": "securepassword123"
}
```

- `password` must be at least 8 characters

**Response (200):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "refresh_token": "v1.MQ...",
  "user_id": "uuid-string",
  "request_id": "req_abc123"
}
```

**Errors:**
- `409 user_already_exists` -- email already registered
- `422 weak_password` -- password doesn't meet requirements

### POST /auth/login

Authenticate with email and password.

**Request:**
```json
{
  "email": "user@example.com",
  "password": "securepassword123"
}
```

**Response (200):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "refresh_token": "v1.MQ...",
  "user_id": "uuid-string",
  "request_id": "req_abc123"
}
```

**Errors:**
- `401 invalid_credentials` -- wrong email or password

---

## Key Management Endpoints

All key management endpoints require a Supabase access token (from POST /auth/login).

### POST /keys

Create a new API key for the authenticated user.

**Headers:** `Authorization: Bearer <access_token>`

**Request:**
```json
{
  "name": "My Trading Bot"
}
```

- `name` is optional (default: "Default"), max 100 characters

**Response (200):**
```json
{
  "data": {
    "id": "uuid-string",
    "key": "kb-abc123def456...",
    "name": "My Trading Bot",
    "key_prefix": "kb-abc1",
    "created_at": "2026-01-15T10:30:00Z"
  },
  "request_id": "req_abc123"
}
```

### GET /keys

List all active API keys for the authenticated user.

**Headers:** `Authorization: Bearer <access_token>`

**Response (200):**
```json
{
  "data": [
    {
      "id": "uuid-string",
      "name": "My Trading Bot",
      "key_prefix": "kb-abc1",
      "created_at": "2026-01-15T10:30:00Z",
      "last_used_at": "2026-02-14T08:15:00Z"
    }
  ],
  "request_id": "req_abc123"
}
```

Note: Raw keys are never returned after creation. Only the prefix is shown for identification.

### DELETE /keys/{key_id}

Revoke an API key. The key must belong to the authenticated user.

**Headers:** `Authorization: Bearer <access_token>`

**Response (200):**
```json
{
  "message": "API key revoked",
  "request_id": "req_abc123"
}
```

**Errors:**
- `404 key_not_found` -- key doesn't exist or already revoked
- `401 invalid_auth_method` -- sent an API key instead of access token

---

## Data Endpoints

All data endpoints require an API key: `Authorization: Bearer kb-YOUR_KEY`

### Endpoint Summary

| Endpoint | Method | Credits | Description |
|----------|--------|---------|-------------|
| `/orderbook` | POST | 5 | Reconstruct L2 orderbook at any timestamp |
| `/deltas` | POST | 2 | Raw orderbook delta events (paginated) |
| `/markets` | GET | 1 | List markets with data coverage |
| `/markets/{ticker}` | GET | 1 | Market metadata and stats |
| `/trades` | POST | 2 | Trade execution history (paginated) |
| `/settlements` | GET | 1 | List settlement results |
| `/settlements/{ticker}` | GET | 1 | Single market settlement |
| `/candles/{ticker}` | GET | 3 | OHLCV candlestick data |
| `/events` | GET | 1 | List events with market counts |
| `/events/{event_ticker}` | GET | 1 | Event detail with nested markets |

### POST /orderbook

Reconstruct the L2 orderbook state at any historical timestamp. KalshiBook stores periodic snapshots and incremental deltas, then replays deltas on top of the nearest snapshot to reconstruct the exact orderbook state at the requested time.

**Request:**
```json
{
  "market_ticker": "KXBTCD-25FEB14-B97000",
  "timestamp": "2026-02-14T12:00:00Z",
  "depth": null
}
```

- `market_ticker` (required): Kalshi market ticker
- `timestamp` (required): ISO 8601 timestamp to reconstruct at
- `depth` (optional): Limit the number of price levels returned (default: all)

**Response (200):**
```json
{
  "market_ticker": "KXBTCD-25FEB14-B97000",
  "timestamp": "2026-02-14T12:00:00Z",
  "snapshot_basis": "2026-02-14T11:55:00Z",
  "deltas_applied": 47,
  "yes": [
    {"price": 65, "quantity": 150},
    {"price": 60, "quantity": 300},
    {"price": 55, "quantity": 200}
  ],
  "no": [
    {"price": 40, "quantity": 100},
    {"price": 35, "quantity": 250}
  ],
  "request_id": "req_abc123",
  "response_time": 0.045
}
```

- `yes` and `no` arrays contain price levels sorted by price descending
- `price` is in cents (1-99 for prediction markets)
- `quantity` is the total number of contracts at that level
- `snapshot_basis` shows which snapshot was used as the reconstruction starting point
- `deltas_applied` shows how many incremental changes were replayed

**Errors:**
- `404 market_not_found` -- ticker doesn't exist in the database
- `404 no_data_available` -- no data exists for the requested timestamp
- `400 invalid_timestamp` -- timestamp is malformed or in the future

### POST /deltas

Query raw orderbook delta events for a market within a time range. Results are paginated using cursor-based pagination for consistent performance.

**Request:**
```json
{
  "market_ticker": "KXBTCD-25FEB14-B97000",
  "start_time": "2026-02-14T10:00:00Z",
  "end_time": "2026-02-14T12:00:00Z",
  "cursor": null,
  "limit": 100
}
```

- `market_ticker` (required): Kalshi market ticker
- `start_time` (required): Start of time range (inclusive)
- `end_time` (required): End of time range (inclusive)
- `cursor` (optional): Pagination cursor from previous response
- `limit` (optional): Results per page, 1-1000 (default: 100)

**Response (200):**
```json
{
  "data": [
    {
      "market_ticker": "KXBTCD-25FEB14-B97000",
      "ts": "2026-02-14T10:00:01.234Z",
      "seq": 12345,
      "price_cents": 65,
      "delta_amount": 50,
      "side": "yes"
    },
    {
      "market_ticker": "KXBTCD-25FEB14-B97000",
      "ts": "2026-02-14T10:00:01.234Z",
      "seq": 12346,
      "price_cents": 35,
      "delta_amount": -25,
      "side": "no"
    }
  ],
  "next_cursor": "eyJ0cyI6IjIwMjYtMDItMTRUMTI6MDA...",
  "has_more": true,
  "request_id": "req_abc123",
  "response_time": 0.032
}
```

- Deltas are ordered by sequence number (`seq`) ascending
- `delta_amount` is positive for additions and negative for removals
- `next_cursor` is null when there are no more results
- Use `next_cursor` as the `cursor` parameter in the next request to paginate

### GET /markets

List all available markets with data coverage information.

**Response (200):**
```json
{
  "data": [
    {
      "ticker": "KXBTCD-25FEB14-B97000",
      "title": "BTC above $97,000 on Feb 14?",
      "event_ticker": "KXBTCD",
      "status": "active",
      "category": "Crypto",
      "first_data_at": "2026-02-10T00:00:00Z",
      "last_data_at": "2026-02-14T15:30:00Z"
    }
  ],
  "request_id": "req_abc123",
  "response_time": 0.015
}
```

- `first_data_at` and `last_data_at` define the time range where orderbook data is available
- Use these to know which timestamps are valid for `/orderbook` queries

### GET /markets/{ticker}

Get detailed metadata for a specific market.

**Response (200):**
```json
{
  "data": {
    "ticker": "KXBTCD-25FEB14-B97000",
    "title": "BTC above $97,000 on Feb 14?",
    "event_ticker": "KXBTCD",
    "status": "active",
    "category": "Crypto",
    "first_data_at": "2026-02-10T00:00:00Z",
    "last_data_at": "2026-02-14T15:30:00Z",
    "rules": "This market will resolve Yes if...",
    "strike_price": 97000.0,
    "discovered_at": "2026-02-10T00:00:00Z",
    "metadata": {},
    "snapshot_count": 576,
    "delta_count": 48320
  },
  "request_id": "req_abc123",
  "response_time": 0.008
}
```

- `snapshot_count` and `delta_count` indicate how much data is available
- More snapshots = faster orderbook reconstruction (less delta replay needed)

### POST /trades

Query trade execution history for a market within a time range. Results are paginated using cursor-based pagination.

**Request:**
```json
{
  "market_ticker": "KXBTCD-25FEB14-B97000",
  "start_time": "2026-02-14T10:00:00Z",
  "end_time": "2026-02-14T12:00:00Z",
  "cursor": null,
  "limit": 100
}
```

- `market_ticker` (required): Kalshi market ticker
- `start_time` (required): Start of time range (inclusive)
- `end_time` (required): End of time range (exclusive)
- `cursor` (optional): Pagination cursor from previous response
- `limit` (optional): Results per page, 1-1000 (default: 100)

**Response (200):**
```json
{
  "data": [
    {
      "trade_id": "abc123-def456",
      "market_ticker": "KXBTCD-25FEB14-B97000",
      "yes_price": 65,
      "no_price": 35,
      "count": 10,
      "taker_side": "yes",
      "ts": "2026-02-14T10:00:01.234Z"
    }
  ],
  "next_cursor": "eyJ0cyI6IjIwMjYtMDItMTRUMTI6MDA...",
  "has_more": true,
  "request_id": "req_abc123",
  "response_time": 0.028
}
```

- `yes_price` and `no_price` are in cents and always sum to 100
- `count` is the number of contracts traded
- `taker_side` indicates which side initiated the trade ("yes" or "no")
- Time range uses exclusive end: `ts >= start_time AND ts < end_time`

### GET /settlements

List settlement results for resolved markets.

**Query Parameters:**
- `event_ticker` (optional): Filter by parent event ticker
- `result` (optional): Filter by settlement result (yes, no, void, all_yes, all_no)

**Response (200):**
```json
{
  "data": [
    {
      "market_ticker": "KXBTCD-25FEB14-B97000",
      "event_ticker": "KXBTCD",
      "result": "yes",
      "settlement_value": 100,
      "determined_at": "2026-02-14T20:00:00Z",
      "settled_at": "2026-02-14T20:05:00Z"
    }
  ],
  "request_id": "req_abc123",
  "response_time": 0.012
}
```

- `settlement_value` is in cents (100 for yes, 0 for no)
- `determined_at` is when the outcome was determined
- `settled_at` is when settlement was finalized and payouts processed
- Results ordered by `determined_at` descending (most recent first)

### GET /settlements/{ticker}

Get settlement data for a specific market.

**Response (200):**
```json
{
  "data": {
    "market_ticker": "KXBTCD-25FEB14-B97000",
    "event_ticker": "KXBTCD",
    "result": "yes",
    "settlement_value": 100,
    "determined_at": "2026-02-14T20:00:00Z",
    "settled_at": "2026-02-14T20:05:00Z"
  },
  "request_id": "req_abc123",
  "response_time": 0.005
}
```

**Errors:**
- `404 settlement_not_found` -- no settlement data for this market

### GET /candles/{ticker}

Get OHLCV candlestick data for a market, computed from raw trade data using SQL aggregation.

**Query Parameters:**
- `start_time` (required): Start of time range, ISO 8601 (inclusive)
- `end_time` (required): End of time range, ISO 8601 (exclusive)
- `interval` (optional): Candle interval -- `1m` (1 minute), `1h` (1 hour, default), `1d` (1 day)

**Example:**
```bash
curl "https://api.kalshibook.com/candles/KXBTCD-25FEB14-B97000?start_time=2026-02-14T10:00:00Z&end_time=2026-02-14T14:00:00Z&interval=1h" \
  -H "Authorization: Bearer kb-YOUR_KEY"
```

**Response (200):**
```json
{
  "data": [
    {
      "bucket": "2026-02-14T10:00:00",
      "market_ticker": "KXBTCD-25FEB14-B97000",
      "open": 62,
      "high": 68,
      "low": 60,
      "close": 65,
      "volume": 450,
      "trade_count": 37
    },
    {
      "bucket": "2026-02-14T11:00:00",
      "market_ticker": "KXBTCD-25FEB14-B97000",
      "open": 65,
      "high": 72,
      "low": 63,
      "close": 70,
      "volume": 620,
      "trade_count": 51
    }
  ],
  "request_id": "req_abc123",
  "response_time": 0.035
}
```

- `open`, `high`, `low`, `close` are yes-side prices in cents (derived from `yes_price` in trades)
- `volume` is total contracts traded in the bucket (`SUM(count)`)
- `trade_count` is the number of individual trade records in the bucket
- **Empty buckets produce no rows.** If there are no trades in a time interval, that bucket is omitted from the response. Consumers typically forward-fill the previous close price for missing intervals.
- Candles are computed from the `trades` table via SQL `date_trunc` aggregation, not proxied from Kalshi

**Errors:**
- `422 validation_error` -- invalid interval (must be 1m, 1h, or 1d)

### GET /events

List events with market counts. Events group related markets (e.g., all BTC price strike levels for a given date).

**Query Parameters:**
- `category` (optional): Filter by event category
- `series_ticker` (optional): Filter by parent series ticker
- `status` (optional): Filter by event status

**Response (200):**
```json
{
  "data": [
    {
      "event_ticker": "KXBTCD-25FEB14",
      "series_ticker": "KXBTCD",
      "title": "Will BTC be above X on Feb 14?",
      "sub_title": "February 14, 2026",
      "category": "Crypto",
      "mutually_exclusive": false,
      "status": "active",
      "market_count": 12
    }
  ],
  "request_id": "req_abc123",
  "response_time": 0.018
}
```

- `market_count` shows how many markets belong to this event
- `mutually_exclusive` indicates if only one market in the event can settle Yes

### GET /events/{event_ticker}

Get event detail with all child markets. Enables multi-market analysis (e.g., viewing all strike prices for an event to build a probability distribution).

**Response (200):**
```json
{
  "data": {
    "event_ticker": "KXBTCD-25FEB14",
    "series_ticker": "KXBTCD",
    "title": "Will BTC be above X on Feb 14?",
    "sub_title": "February 14, 2026",
    "category": "Crypto",
    "mutually_exclusive": false,
    "status": "active",
    "market_count": 3,
    "markets": [
      {
        "ticker": "KXBTCD-25FEB14-B95000",
        "title": "BTC above $95,000 on Feb 14?",
        "event_ticker": "KXBTCD-25FEB14",
        "status": "active",
        "category": "Crypto"
      },
      {
        "ticker": "KXBTCD-25FEB14-B97000",
        "title": "BTC above $97,000 on Feb 14?",
        "event_ticker": "KXBTCD-25FEB14",
        "status": "active",
        "category": "Crypto"
      },
      {
        "ticker": "KXBTCD-25FEB14-B99000",
        "title": "BTC above $99,000 on Feb 14?",
        "event_ticker": "KXBTCD-25FEB14",
        "status": "active",
        "category": "Crypto"
      }
    ]
  },
  "request_id": "req_abc123",
  "response_time": 0.022
}
```

- `markets` contains all markets for the event, ordered by ticker
- Each market includes basic summary fields (use `GET /markets/{ticker}` for full detail)

**Errors:**
- `404 event_not_found` -- event ticker doesn't exist in the database

---

## Error Handling

All errors return a consistent JSON envelope:

```json
{
  "error": {
    "code": "error_code",
    "message": "Human-readable error description",
    "status": 401
  },
  "request_id": "req_abc123"
}
```

### Error Codes

| Code | Status | Description |
|------|--------|-------------|
| `invalid_api_key` | 401 | API key is missing, malformed, or revoked |
| `invalid_credentials` | 401 | Wrong email or password |
| `invalid_auth_method` | 401 | Used API key where access token is needed (or vice versa) |
| `user_already_exists` | 409 | Email already registered |
| `weak_password` | 422 | Password doesn't meet strength requirements |
| `validation_error` | 422 | Request body failed validation |
| `market_not_found` | 404 | Market ticker doesn't exist |
| `event_not_found` | 404 | Event ticker doesn't exist |
| `settlement_not_found` | 404 | No settlement data for this market |
| `no_data_available` | 404 | No data for the requested time range |
| `key_not_found` | 404 | API key not found or already revoked |
| `invalid_timestamp` | 400 | Timestamp is malformed or out of range |
| `credits_exhausted` | 429 | Monthly credit limit reached, enable PAYG or upgrade |
| `no_billing_account` | 400 | No Stripe customer exists, subscribe first via checkout |
| `invalid_payload` | 400 | Webhook payload could not be parsed |
| `invalid_signature` | 400 | Webhook Stripe signature verification failed |
| `rate_limit_exceeded` | 429 | Too many requests, retry after indicated time |
| `internal_error` | 500 | Unexpected server error |

---

## Billing & Credits

### Credit System Overview

Every API request to data endpoints costs credits. Credits are deducted atomically on each request. The credit balance resets monthly on the billing cycle start date. Unused credits do not roll over.

**Credit costs per endpoint:**

| Endpoint | Cost |
|----------|------|
| `GET /markets` | 1 credit |
| `GET /markets/{ticker}` | 1 credit |
| `GET /events` | 1 credit |
| `GET /events/{event_ticker}` | 1 credit |
| `GET /settlements` | 1 credit |
| `GET /settlements/{ticker}` | 1 credit |
| `POST /trades` | 2 credits |
| `POST /deltas` | 2 credits |
| `GET /candles/{ticker}` | 3 credits |
| `POST /orderbook` | 5 credits |

Billing endpoints (`/billing/*`), auth endpoints (`/auth/*`), and key management endpoints (`/keys`) cost zero credits.

### Tier Comparison

| Feature | Free | Pay-As-You-Go | Project |
|---------|------|---------------|---------|
| Monthly credits | 1,000 | 1,000 + overage | 4,000 |
| Price | $0/month | $0/month + $0.008/credit overage | $30/month |
| Rate limit | 30 req/min | 60 req/min | 120 req/min |
| Overage billing | No (429 when exhausted) | Yes (Stripe metered) | No (429 when exhausted) |
| Stripe subscription | Not required | Not required | Required |

All new accounts start on the **Free** tier with 1,000 credits/month.

### Credit Response Headers

Every data endpoint response includes credit headers:

| Header | Description |
|--------|-------------|
| `X-Credits-Remaining` | Credits remaining after this request |
| `X-Credits-Used` | Total credits consumed this billing cycle |
| `X-Credits-Total` | Total credit allocation for this billing cycle |
| `X-Credits-Cost` | Credits charged for this specific request |

Example response headers:
```
X-Credits-Remaining: 994
X-Credits-Used: 6
X-Credits-Total: 1000
X-Credits-Cost: 5
```

### Credit Exhaustion

When credits are exhausted (and PAYG is not enabled), requests return 429:

```json
{
  "error": {
    "code": "credits_exhausted",
    "message": "Monthly credit limit reached. Enable PAYG or upgrade to Project for more credits.",
    "status": 429
  },
  "request_id": "req_abc123"
}
```

**Options when credits are exhausted:**
1. Wait for monthly reset (billing cycle start date)
2. Enable Pay-As-You-Go via `POST /billing/payg` (overage at $0.008/credit)
3. Upgrade to Project plan via `POST /billing/checkout` (4,000 credits/month)

### Billing Endpoints

All billing endpoints require a **Supabase JWT access token** (from `POST /auth/login`), NOT an API key. Send the token as `Authorization: Bearer <access_token>`.

#### GET /billing/status

Check current billing tier, credit usage, and PAYG status.

**Headers:** `Authorization: Bearer <access_token>`

**Response (200):**
```json
{
  "tier": "free",
  "credits_total": 1000,
  "credits_used": 47,
  "credits_remaining": 953,
  "payg_enabled": false,
  "billing_cycle_start": "2026-02-01T00:00:00",
  "request_id": "req_abc123"
}
```

- `tier`: One of `free`, `payg`, or `project`
- `credits_remaining`: Computed as `credits_total - credits_used` (minimum 0)
- `billing_cycle_start`: Start of the current monthly billing period

#### POST /billing/checkout

Create a Stripe Checkout Session to upgrade to the Project plan ($30/month, 4,000 credits).

**Headers:** `Authorization: Bearer <access_token>`

**Response (200):**
```json
{
  "checkout_url": "https://checkout.stripe.com/c/pay/cs_test_...",
  "request_id": "req_abc123"
}
```

- Redirect the user to `checkout_url` to complete payment
- A Stripe customer is created automatically if one does not exist
- After successful payment, a webhook updates the account to `project` tier with 4,000 credits

#### POST /billing/portal

Create a Stripe Customer Portal session for managing an existing subscription (cancel, update payment method, view invoices).

**Headers:** `Authorization: Bearer <access_token>`

**Response (200):**
```json
{
  "portal_url": "https://billing.stripe.com/p/session/...",
  "request_id": "req_abc123"
}
```

**Errors:**
- `400 no_billing_account` -- User has no Stripe customer. Must subscribe first via `POST /billing/checkout`.

#### POST /billing/payg

Enable or disable Pay-As-You-Go overage billing.

**Headers:** `Authorization: Bearer <access_token>`

**Request:**
```json
{
  "enable": true
}
```

**Response (200):**
```json
{
  "payg_enabled": true,
  "message": "Pay-As-You-Go enabled. Overage credits will be billed at $0.008/credit.",
  "request_id": "req_abc123"
}
```

- When enabling PAYG, a Stripe customer is created automatically if one does not exist
- PAYG allows exceeding the credit allocation; overage is billed via Stripe metered billing
- Disabling PAYG returns: `"Pay-As-You-Go disabled. API access will stop when credits are exhausted."`

### Upgrade Flow for AI Agents

When an AI agent encounters credit limits, follow this flow:

1. **Check status:** `GET /billing/status` to see current tier and credits remaining
2. **If credits low or exhausted:**
   - Option A: Call `POST /billing/checkout` and present the `checkout_url` to the human user to complete payment in their browser
   - Option B: Call `POST /billing/payg` with `{"enable": true}` to enable overage billing (no human interaction needed if Stripe customer exists)
3. **After human completes Stripe Checkout:** Credits increase automatically via webhook (tier becomes `project`, credits_total becomes 4,000)
4. **Retry the original request** -- credits are now available

**Important:** AI agents cannot complete Stripe Checkout themselves. The `checkout_url` must be opened by a human user in a browser. PAYG toggle is fully API-driven and does not require human interaction (after initial Stripe customer creation).

### Billing Error Codes

| Code | Status | Description |
|------|--------|-------------|
| `credits_exhausted` | 429 | Monthly credit limit reached, enable PAYG or upgrade |
| `no_billing_account` | 400 | No Stripe customer exists, subscribe first via checkout |
| `invalid_payload` | 400 | Webhook payload could not be parsed |
| `invalid_signature` | 400 | Webhook Stripe signature verification failed |

---

## Rate Limiting

Rate limits are tier-dependent. Free: 30 req/min. PAYG: 60 req/min. Project: 120 req/min. A global backstop of 120 req/min applies to all users.

Rate limit status is returned in response headers:

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests allowed in the window |
| `X-RateLimit-Remaining` | Requests remaining in the current window |
| `X-RateLimit-Reset` | Unix timestamp when the window resets |

When rate limited (429 response), the `Retry-After` header indicates seconds to wait.

Unauthenticated endpoints (/auth/signup, /auth/login) are rate-limited by IP address.

---

## Backtesting Workflow

A complete backtesting workflow using KalshiBook:

1. **Discover events:** `GET /events` to find event groups with multiple strike levels
2. **Explore event markets:** `GET /events/{event_ticker}` to see all markets for an event
3. **Discover markets:** `GET /markets` to find markets with data
4. **Check coverage:** Look at `first_data_at` and `last_data_at` for your target market
5. **Get candles for strategy signals:** `GET /candles/{ticker}?interval=1h` for directional/momentum analysis
6. **Get trade history:** `POST /trades` for tick-level execution data
7. **Sample orderbook state:** `POST /orderbook` at each timestamp in your backtest for spread/depth analysis
8. **Get raw deltas:** `POST /deltas` for tick-level orderbook changes
9. **Check outcomes:** `GET /settlements/{ticker}` to verify strategy P&L against actual results

### Example: Backtest a momentum strategy using candles

```python
import httpx

BASE = "https://api.kalshibook.com"
HEADERS = {"Authorization": "Bearer kb-YOUR_KEY"}

# 1. Find events in a category
events = httpx.get(f"{BASE}/events", headers=HEADERS, params={
    "category": "Crypto"
}).json()

# 2. Get markets for an event
event_ticker = events["data"][0]["event_ticker"]
event = httpx.get(f"{BASE}/events/{event_ticker}", headers=HEADERS).json()
print(f"Event has {len(event['data']['markets'])} markets")

# 3. Get hourly candles for a market
ticker = event["data"]["markets"][0]["ticker"]
candles = httpx.get(f"{BASE}/candles/{ticker}", headers=HEADERS, params={
    "start_time": "2026-02-14T08:00:00Z",
    "end_time": "2026-02-14T20:00:00Z",
    "interval": "1h"
}).json()

for c in candles["data"]:
    print(f"  {c['bucket']}: O={c['open']} H={c['high']} L={c['low']} C={c['close']} V={c['volume']}")

# 4. Check settlement outcome
settlement = httpx.get(f"{BASE}/settlements/{ticker}", headers=HEADERS).json()
print(f"Result: {settlement['data']['result']}")

# 5. Get raw trades for fine-grained analysis
trades = httpx.post(f"{BASE}/trades", headers=HEADERS, json={
    "market_ticker": ticker,
    "start_time": "2026-02-14T12:00:00Z",
    "end_time": "2026-02-14T13:00:00Z",
    "limit": 500
}).json()
print(f"Got {len(trades['data'])} trades")
```

### Example: Build a probability distribution from event markets

```python
import httpx

BASE = "https://api.kalshibook.com"
HEADERS = {"Authorization": "Bearer kb-YOUR_KEY"}

# Get all markets for an event
event = httpx.get(f"{BASE}/events/KXBTCD-25FEB14", headers=HEADERS).json()

# Get the latest orderbook for each strike level
for market in event["data"]["markets"]:
    book = httpx.post(f"{BASE}/orderbook", headers=HEADERS, json={
        "market_ticker": market["ticker"],
        "timestamp": "2026-02-14T12:00:00Z"
    }).json()

    # Best yes bid = implied probability
    if book["yes"]:
        implied_prob = book["yes"][0]["price"] / 100
        print(f"  {market['ticker']}: {implied_prob:.0%} implied probability")
```

---

## Orderbook Reconstruction

KalshiBook reconstructs orderbook state using a snapshot-plus-delta approach:

1. The system stores periodic snapshots of the full orderbook (every ~5 minutes)
2. Between snapshots, every change to the orderbook is recorded as a delta
3. To reconstruct the orderbook at timestamp T:
   - Find the most recent snapshot before T
   - Fetch all deltas between that snapshot and T
   - Apply each delta to the snapshot in sequence order

This approach provides exact orderbook state at any historical point while keeping storage efficient.

---

## Optional Endpoints

### GET /health

Health check endpoint. Returns 200 if the service is running.

```json
{"status": "ok"}
```

### GET /llms.txt

This file -- AI agent discovery information (markdown).

### GET /llms-full.txt

Comprehensive API reference for AI agents (this document).
